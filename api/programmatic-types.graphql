# File generated by "php artisan lighthouse:ide-helper".
# Do not edit this file directly.
# This file should be ignored by git as it can be autogenerated.

"""
The `String` scalar type represents textual data, represented as UTF-8
character sequences. The String type is most often used by GraphQL to
represent free-form human-readable text.
"""
scalar String

"""
The `ID` scalar type represents a unique identifier, often used to
refetch an object or as key for a cache. The ID type appears in a JSON
response as a String; however, it is not intended to be human-readable.
When expected as an input type, any string (such as `"4"`) or integer
(such as `4`) input value will be accepted as an ID.
"""
scalar ID

"The `Boolean` scalar type represents `true` or `false`."
scalar Boolean

"""
The `Int` scalar type represents non-fractional signed whole numeric
values. Int can represent values between -(2^31) and 2^31 - 1. 
"""
scalar Int

"Information about pagination using a fully featured paginator."
type PaginatorInfo {
  "Number of items in the current page."
  count: Int!

  "Index of the current page."
  currentPage: Int!

  "Index of the first item in the current page."
  firstItem: Int

  "Are there more pages after this one?"
  hasMorePages: Boolean!

  "Index of the last item in the current page."
  lastItem: Int

  "Index of the last available page."
  lastPage: Int!

  "Number of items per page."
  perPage: Int!

  "Number of total available items."
  total: Int!
}

"A paginated list of User items."
type UserPaginator {
  "Pagination information about the list of items."
  paginatorInfo: PaginatorInfo!

  "A list of User items."
  data: [User!]!
}

"A paginated list of PoolCandidateWithSkillCount items."
type PoolCandidateWithSkillCountPaginator {
  "Pagination information about the list of items."
  paginatorInfo: PaginatorInfo!

  "A list of PoolCandidateWithSkillCount items."
  data: [PoolCandidateWithSkillCount!]!
}

"A paginated list of PoolCandidateSearchRequest items."
type PoolCandidateSearchRequestPaginator {
  "Pagination information about the list of items."
  paginatorInfo: PaginatorInfo!

  "A list of PoolCandidateSearchRequest items."
  data: [PoolCandidateSearchRequest!]!
}

"Allowed column names for Query.poolCandidatesPaginated.orderBy."
enum QueryPoolCandidatesPaginatedOrderByUserColumn {
  PRIORITY_WEIGHT
  FIRST_NAME
  EMAIL
  PREFERRED_LANG
  PREFERRED_LANGUAGE_FOR_INTERVIEW
  PREFERRED_LANGUAGE_FOR_EXAM
  CURRENT_CITY
}

"Aggregate specification for Query.poolCandidatesPaginated.orderBy.user."
input QueryPoolCandidatesPaginatedOrderByUser {
  "The aggregate function to apply to the column."
  aggregate: OrderByRelationWithColumnAggregateFunction!

  "Name of the column to use."
  column: QueryPoolCandidatesPaginatedOrderByUserColumn
}

"Order by clause for Query.poolCandidatesPaginated.orderBy."
input QueryPoolCandidatesPaginatedOrderByRelationOrderByClause {
  "The column that is used for ordering."
  column: String

  "The direction that is used for ordering."
  order: SortOrder!

  "Aggregate specification."
  user: QueryPoolCandidatesPaginatedOrderByUser
}

"Directions for ordering a list of records."
enum SortOrder {
  "Sort records in ascending order."
  ASC

  "Sort records in descending order."
  DESC
}

"Aggregate functions when ordering by a relation without specifying a column."
enum OrderByRelationAggregateFunction {
  "Amount of items."
  COUNT
}

"Aggregate functions when ordering by a relation that may specify a column."
enum OrderByRelationWithColumnAggregateFunction {
  "Average."
  AVG

  "Minimum."
  MIN

  "Maximum."
  MAX

  "Sum."
  SUM

  "Amount of items."
  COUNT
}

"Allows ordering a list of records."
input OrderByClause {
  "The column that is used for ordering."
  column: String!

  "The direction that is used for ordering."
  order: SortOrder!
}

"Specify if you want to include or exclude trashed results from a query."
enum Trashed {
  "Only return trashed results."
  ONLY

  "Return both trashed and non-trashed results."
  WITH

  "Only return non-trashed results."
  WITHOUT
}

"Dynamic WHERE conditions for queries."
input WhereConditions {
  "The column that is used for the condition."
  column: String

  "The operator that is used for the condition."
  operator: SQLOperator = EQ

  "The value that is used for the condition."
  value: Mixed

  "A set of conditions that requires all conditions to match."
  AND: [WhereConditions!]

  "A set of conditions that requires at least one condition to match."
  OR: [WhereConditions!]

  "Check whether a relation exists. Extra conditions or a minimum amount can be applied."
  HAS: WhereConditionsRelation
}

"Dynamic HAS conditions for WHERE condition queries."
input WhereConditionsRelation {
  "The relation that is checked."
  relation: String!

  "The comparison operator to test against the amount."
  operator: SQLOperator = GTE

  "The amount to test."
  amount: Int = 1

  "Additional condition logic."
  condition: WhereConditions
}

"The available SQL operators that are used to filter query results."
enum SQLOperator {
  "Equal operator (`=`)"
  EQ

  "Not equal operator (`!=`)"
  NEQ

  "Greater than operator (`>`)"
  GT

  "Greater than or equal operator (`>=`)"
  GTE

  "Less than operator (`<`)"
  LT

  "Less than or equal operator (`<=`)"
  LTE

  "Simple pattern matching (`LIKE`)"
  LIKE

  "Negation of simple pattern matching (`NOT LIKE`)"
  NOT_LIKE

  "Whether a value is within a set of values (`IN`)"
  IN

  "Whether a value is not within a set of values (`NOT IN`)"
  NOT_IN

  "Whether a value is within a range of values (`BETWEEN`)"
  BETWEEN

  "Whether a value is not within a range of values (`NOT BETWEEN`)"
  NOT_BETWEEN

  "Whether a value is null (`IS NULL`)"
  IS_NULL

  "Whether a value is not null (`IS NOT NULL`)"
  IS_NOT_NULL

  "Whether a set of values contains a value (`@>`)"
  CONTAINS
}

"""
Loose type that allows any value. Be careful when passing in large `Int` or `Float` literals,
as they may not be parsed correctly on the server side. Use `String` literals if you are
dealing with really large numbers to be on the safe side.
"""
scalar Mixed

enum Language {
  EN
  FR
}

enum ProvinceOrTerritory {
  BRITISH_COLUMBIA
  ALBERTA
  SASKATCHEWAN
  MANITOBA
  ONTARIO
  QUEBEC
  NEW_BRUNSWICK
  NOVA_SCOTIA
  PRINCE_EDWARD_ISLAND
  NEWFOUNDLAND_AND_LABRADOR
  YUKON
  NORTHWEST_TERRITORIES
  NUNAVUT
}

enum GovEmployeeType {
  STUDENT
  CASUAL
  TERM
  INDETERMINATE
}

enum BilingualEvaluation {
  COMPLETED_ENGLISH
  COMPLETED_FRENCH
  NOT_COMPLETED
}

enum EvaluatedLanguageAbility {
  X
  A
  B
  C
  E
  P
  NOT_ASSESSED
}

enum EstimatedLanguageAbility {
  BEGINNER
  INTERMEDIATE
  ADVANCED
}

enum CitizenshipStatus {
  PERMANENT_RESIDENT
  CITIZEN
  OTHER
}

enum ArmedForcesStatus {
  VETERAN
  MEMBER
  NON_CAF
}

enum PositionDuration {
  TEMPORARY
  PERMANENT
}

enum IndigenousCommunity {
  STATUS_FIRST_NATIONS
  NON_STATUS_FIRST_NATIONS
  INUIT
  METIS
  OTHER
  LEGACY_IS_INDIGENOUS
}

enum PoolSkillType {
  ESSENTIAL
  NONESSENTIAL
}

enum PoolStream {
  ACCESS_INFORMATION_PRIVACY
  BUSINESS_ADVISORY_SERVICES
  DATABASE_MANAGEMENT
  ENTERPRISE_ARCHITECTURE
  INFRASTRUCTURE_OPERATIONS
  PLANNING_AND_REPORTING
  PROJECT_PORTFOLIO_MANAGEMENT
  SECURITY
  SOFTWARE_SOLUTIONS
  INFORMATION_DATA_FUNCTIONS
}

enum PoolStatus {
  DRAFT
  PUBLISHED
  CLOSED
  ARCHIVED
}

enum PoolCandidateStatus {
  DRAFT
  DRAFT_EXPIRED
  NEW_APPLICATION
  APPLICATION_REVIEW
  SCREENED_IN
  SCREENED_OUT_APPLICATION
  SCREENED_OUT_NOT_INTERESTED
  SCREENED_OUT_NOT_RESPONSIVE
  UNDER_ASSESSMENT
  SCREENED_OUT_ASSESSMENT
  QUALIFIED_AVAILABLE
  QUALIFIED_UNAVAILABLE
  QUALIFIED_WITHDREW
  PLACED_CASUAL
  PLACED_TERM
  PLACED_INDETERMINATE
  EXPIRED
  REMOVED
}

enum SecurityStatus {
  RELIABILITY
  SECRET
  TOP_SECRET
}

enum PoolLanguage {
  ENGLISH
  FRENCH
  VARIOUS
  BILINGUAL_INTERMEDIATE
  BILINGUAL_ADVANCED
}

enum PublishingGroup {
  IAP
  IT_JOBS
  IT_JOBS_ONGOING
  EXECUTIVE_JOBS
  OTHER
}

enum ApplicationStep {
  WELCOME
  SELF_DECLARATION
  REVIEW_YOUR_PROFILE
  REVIEW_YOUR_RESUME
  EDUCATION_REQUIREMENTS
  SKILL_REQUIREMENTS
  SCREENING_QUESTIONS
  REVIEW_AND_SUBMIT
}

enum EducationRequirementOption {
  APPLIED_WORK
  EDUCATION
}

enum LanguageAbility {
  ENGLISH
  FRENCH
  BILINGUAL
}

enum WorkRegion {
  TELEWORK
  NATIONAL_CAPITAL
  ATLANTIC
  QUEBEC
  ONTARIO
  PRAIRIE
  BRITISH_COLUMBIA
  NORTH
}

enum OperationalRequirement {
  SHIFT_WORK
  ON_CALL
  TRAVEL
  TRANSPORT_EQUIPMENT
  DRIVERS_LICENSE
  OVERTIME_SCHEDULED
  OVERTIME_SHORT_NOTICE
  OVERTIME_OCCASIONAL
  OVERTIME_REGULAR
}

enum SalaryRange {
  _50_59K
  _60_69K
  _70_79K
  _80_89K
  _90_99K
  _100K_PLUS
}

enum GenericJobTitleKey {
  TECHNICIAN_IT01
  ANALYST_IT02
  TEAM_LEADER_IT03
  TECHNICAL_ADVISOR_IT03
  SENIOR_ADVISOR_IT04
  MANAGER_IT04
}

enum PoolCandidateSearchStatus {
  NEW
  IN_PROGRESS
  WAITING
  DONE
}

enum PoolCandidateSearchPositionType {
  INDIVIDUAL_CONTRIBUTOR
  TEAM_LEAD
}

enum SkillCategory {
  TECHNICAL
  BEHAVIOURAL
}

enum SkillLevel {
  BEGINNER
  INTERMEDIATE
  ADVANCED
  LEAD
}

enum WhenSkillUsed {
  CURRENT
  PAST
}

enum AwardedTo {
  ME
  MY_TEAM
  MY_PROJECT
  MY_ORGANIZATION
}

enum AwardedScope {
  INTERNATIONAL
  NATIONAL
  PROVINCIAL
  LOCAL
  COMMUNITY
  ORGANIZATIONAL
  SUB_ORGANIZATIONAL
}

enum EducationType {
  DIPLOMA
  BACHELORS_DEGREE
  MASTERS_DEGREE
  PHD
  POST_DOCTORAL_FELLOWSHIP
  ONLINE_COURSE
  CERTIFICATION
  OTHER
}

enum EducationStatus {
  SUCCESS_CREDENTIAL
  SUCCESS_NO_CREDENTIAL
  IN_PROGRESS
  AUDITED
  DID_NOT_COMPLETE
}

enum CandidateExpiryFilter {
  ACTIVE
  EXPIRED
  ALL
}

enum CandidateSuspendedFilter {
  ACTIVE
  SUSPENDED
  ALL
}

enum AdvertisementType {
  INTERNAL
  EXTERNAL
}

enum AdvertisingPlatform {
  GCJOBS
  GCCONNEX
  GCXCHNAGE
  GC_COLLAB
  FACEBOOK
  LINKEDIN
  OTHER
}

enum ContractAuthority {
  HR
  PROCUREMENT
  FINANCE
  LABOUR_RELATIONS
  OTHER
}

enum YesNo {
  YES
  NO
}

enum YesNoUnsure {
  YES
  NO
  I_DONT_KNOW
}

enum ContractValueRange {
  FROM_0_TO_10K
  FROM_10K_TO_25K
  FROM_25K_TO_50K
  FROM_50K_TO_1M
  FROM_1M_TO_2500K
  FROM_2500K_TO_5M
  FROM_5M_TO_10M
  FROM_10M_TO_15M
  FROM_15M_TO_25M
  GREATER_THAN_25M
}

enum ContractStartTimeframe {
  FROM_0_TO_3M
  FROM_3M_TO_6M
  FROM_6M_TO_1Y
  FROM_1Y_TO_2Y
  UNKNOWN
  VARIABLE
}

enum ContractCommodity {
  TELECOM_SERVICES
  SUPPORT_SERVICES
  OTHER
}

enum ContractFteRange {
  FROM_1_TO_5
  FROM_6_TO_10
  FROM_11_TO_30
  FROM_31_TO_50
  FROM_51_TO_100
  GREATER_THAN_100
}

enum ContractInstrument {
  SUPPLY_ARRANGEMENT
  STANDING_OFFER
  CONTRACT
  AMENDMENT
  OTHER
}

enum ContractSupplyMethod {
  NOT_APPLICABLE
  SOLUTIONS_BASED_INFORMATICS_PROFESSIONAL_SERVICES
  TASK_BASED_INFORMATICS_PROFESSIONAL_SERVICES
  TEMPORARY_HELP
  OTHER
}

enum ContractSolicitationProcedure {
  ADVANCE_CONTRACT_AWARD_NOTICE
  COMPETITIVE
  NON_COMPETITIVE
}

enum PersonnelScreeningLevel {
  RELIABILITY
  ENHANCED_RELIABILITY
  SECRET
  TOP_SECRET
  OTHER
}

enum PersonnelLanguage {
  ENGLISH_ONLY
  FRENCH_ONLY
  BILINGUAL_INTERMEDIATE
  BILINGUAL_ADVANCED
  OTHER
}

enum PersonnelWorkLocation {
  GC_PREMISES
  OFFSITE_SPECIFIC
  OFFSITE_ANY
}

enum PositionEmploymentType {
  INDETERMINATE
  TERM
  LATERAL_DEPLOYMENT
  SECONDMENT
  ASSIGNMENT
  OTHER
}

enum PersonnelOtherRequirement {
  SHIFT_WORK
  ON_CALL_24_7
  OVERTIME_SHORT_NOTICE
  AS_NEEDED
  OTHER
}

enum PersonnelSkillExpertiseLevel {
  BEGINNER
  INTERMEDIATE
  EXPERT
  LEAD
}

enum PersonnelTeleworkOption {
  FULL_TIME
  PART_TIME
  NO
}

enum OperationsConsideration {
  FINANCE_VEHICLE_NOT_USABLE
  FUNDING_SECURED_COST_RECOVERY_BASIS
  UNABLE_CREATE_NEW_INDETERMINATE
  UNABLE_CREATE_NEW_TERM
  UNABLE_CREATE_CLASSIFICATION_RESTRICTION
  STAFFING_FREEZE
  OTHER
}

enum ContractingRationale {
  SHORTAGE_OF_TALENT
  TIMING_REQUIREMENTS
  HR_SITUATION
  FINANCIAL_SITUATION
  REQUIRES_INDEPENDENT
  INTELLECTUAL_PROPERTY_FACTORS
  OTHER
}

enum AssessmentStepType {
  SCREENING_QUESTIONS_AT_APPLICATION
  TECHNICAL_EXAM_AT_SITE
  TECHNICAL_EXAM_AT_HOME
  PSC_EXAM
  INTERVIEW_GROUP
  INTERVIEW_INDIVIDUAL
  INTERVIEW_FOLLOWUP
  REFERENCE_CHECK
  APPLICATION_SCREENING
  ADDITIONAL_ASSESSMENT
}

enum AssessmentResultType {
  EDUCATION
  SKILL
}

enum AssessmentDecision {
  NOT_SURE
  SUCCESSFUL
  UNSUCCESSFUL
}

enum AssessmentResultJustification {
  EDUCATION_ACCEPTED_INFORMATION
  EDUCATION_ACCEPTED_WORK_EXPERIENCE_EQUIVALENCY
  EDUCATION_ACCEPTED_COMBINATION_EDUCATION_WORK_EXPERIENCE
  EDUCATION_FAILED_NOT_RELEVANT
  EDUCATION_FAILED_REQUIREMENT_NOT_MET
  SKILL_ACCEPTED
  SKILL_FAILED_INSUFFICIENTLY_DEMONSTRATED
  FAILED_NOT_ENOUGH_INFORMATION
  FAILED_OTHER
}

enum AssessmentDecisionLevel {
  AT_REQUIRED
  ABOVE_REQUIRED
  ABOVE_AND_BEYOND_REQUIRED
}

"A GraphQL Schema defines the capabilities of a GraphQL server. It exposes all available types and directives on the server, as well as the entry points for query, mutation, and subscription operations."
type __Schema {
  "A list of all types supported by this server."
  types: [__Type!]!

  "The type that query operations will be rooted at."
  queryType: __Type!

  "If this server supports mutation, the type that mutation operations will be rooted at."
  mutationType: __Type

  "If this server support subscription, the type that subscription operations will be rooted at."
  subscriptionType: __Type

  "A list of all directives supported by this server."
  directives: [__Directive!]!
}

"""
The fundamental unit of any GraphQL Schema is the type. There are many kinds of types in GraphQL as represented by the `__TypeKind` enum.

Depending on the kind of a type, certain fields describe information about that type. Scalar types provide no information beyond a name and description, while Enum types provide their values. Object and Interface types provide the fields they describe. Abstract types, Union and Interface, provide the Object types possible at runtime. List and NonNull types compose other types.
"""
type __Type {
  kind: __TypeKind!
  name: String
  description: String
  fields(includeDeprecated: Boolean = false): [__Field!]
  interfaces: [__Type!]
  possibleTypes: [__Type!]
  enumValues(includeDeprecated: Boolean = false): [__EnumValue!]
  inputFields(includeDeprecated: Boolean = false): [__InputValue!]
  ofType: __Type
}

"An enum describing what kind of type a given `__Type` is."
enum __TypeKind {
  "Indicates this type is a scalar."
  SCALAR

  "Indicates this type is an object. `fields` and `interfaces` are valid fields."
  OBJECT

  "Indicates this type is an interface. `fields`, `interfaces`, and `possibleTypes` are valid fields."
  INTERFACE

  "Indicates this type is a union. `possibleTypes` is a valid field."
  UNION

  "Indicates this type is an enum. `enumValues` is a valid field."
  ENUM

  "Indicates this type is an input object. `inputFields` is a valid field."
  INPUT_OBJECT

  "Indicates this type is a list. `ofType` is a valid field."
  LIST

  "Indicates this type is a non-null. `ofType` is a valid field."
  NON_NULL
}

"Object and Interface types are described by a list of Fields, each of which has a name, potentially a list of arguments, and a return type."
type __Field {
  name: String!
  description: String
  args(includeDeprecated: Boolean = false): [__InputValue!]!
  type: __Type!
  isDeprecated: Boolean!
  deprecationReason: String
}

"Arguments provided to Fields or Directives and the input fields of an InputObject are represented as Input Values which describe their type and optionally a default value."
type __InputValue {
  name: String!
  description: String
  type: __Type!

  "A GraphQL-formatted string representing the default value for this input value."
  defaultValue: String

  isDeprecated: Boolean!
  deprecationReason: String
}

"One possible value for a given Enum. Enum values are unique values, not a placeholder for a string or numeric value. However an Enum value is returned in a JSON response as a string."
type __EnumValue {
  name: String!
  description: String
  isDeprecated: Boolean!
  deprecationReason: String
}

"""
A Directive provides a way to describe alternate runtime execution and type validation behavior in a GraphQL document.

In some cases, you need to provide options to alter GraphQL's execution behavior in ways field arguments will not suffice, such as conditionally including or skipping a field. Directives provide this by describing additional information to the executor.
"""
type __Directive {
  name: String!
  description: String
  isRepeatable: Boolean!
  locations: [__DirectiveLocation!]!
  args: [__InputValue!]!
}

"A Directive can be adjacent to many parts of the GraphQL language, a __DirectiveLocation describes one such possible adjacencies."
enum __DirectiveLocation {
  "Location adjacent to a query operation."
  QUERY

  "Location adjacent to a mutation operation."
  MUTATION

  "Location adjacent to a subscription operation."
  SUBSCRIPTION

  "Location adjacent to a field."
  FIELD

  "Location adjacent to a fragment definition."
  FRAGMENT_DEFINITION

  "Location adjacent to a fragment spread."
  FRAGMENT_SPREAD

  "Location adjacent to an inline fragment."
  INLINE_FRAGMENT

  "Location adjacent to a variable definition."
  VARIABLE_DEFINITION

  "Location adjacent to a schema definition."
  SCHEMA

  "Location adjacent to a scalar definition."
  SCALAR

  "Location adjacent to an object type definition."
  OBJECT

  "Location adjacent to a field definition."
  FIELD_DEFINITION

  "Location adjacent to an argument definition."
  ARGUMENT_DEFINITION

  "Location adjacent to an interface definition."
  INTERFACE

  "Location adjacent to a union definition."
  UNION

  "Location adjacent to an enum definition."
  ENUM

  "Location adjacent to an enum value definition."
  ENUM_VALUE

  "Location adjacent to an input object type definition."
  INPUT_OBJECT

  "Location adjacent to an input object field definition."
  INPUT_FIELD_DEFINITION
}
