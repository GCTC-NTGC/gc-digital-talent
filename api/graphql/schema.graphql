"A date string with format `Y-m-d`, e.g. `2011-05-23`."
scalar Date @scalar(class: "Nuwave\\Lighthouse\\Schema\\Types\\Scalars\\Date")

"A datetime string with format `Y-m-d H:i:s`, e.g. `2018-05-23 13:43:32`."
scalar DateTime
  @scalar(class: "Nuwave\\Lighthouse\\Schema\\Types\\Scalars\\DateTime")

"A RFC 5321 compliant email."
scalar Email @scalar(class: "MLL\\GraphQLScalars\\Email")

"A phone number string, accepts any string"
scalar PhoneNumber

"A human readable ID"
scalar KeyString

"Arbitrary data encoded in JavaScript Object Notation. See https://www.json.org."
scalar JSON @scalar(class: "MLL\\GraphQLScalars\\JSON")

"128 bit universally unique identifier (UUID)"
scalar UUID @scalar(class: "UUID")

type LocalizedString {
  en: String
  fr: String
}

type LocalizedEnumString {
  value: String!
  label: LocalizedString!
}

type UserAuthInfo {
  id: UUID!
  sub: String
  roleAssignments: [RoleAssignment] @hasMany
  createdDate: DateTime @rename(attribute: "created_at")
  deletedDate: DateTime @rename(attribute: "deleted_at")
}

type User {
  id: ID!
  createdDate: DateTime @rename(attribute: "created_at")
  updatedDate: DateTime @rename(attribute: "updated_at")
  deletedDate: DateTime @rename(attribute: "deleted_at")

  # Personal info
  firstName: String @rename(attribute: "first_name")
  lastName: String @rename(attribute: "last_name")
  email: Email
  isEmailVerified: Boolean
  telephone: PhoneNumber
  preferredLang: LocalizedLanguage @rename(attribute: "preferred_lang")
  preferredLanguageForInterview: LocalizedLanguage
    @rename(attribute: "preferred_language_for_interview")
  preferredLanguageForExam: LocalizedLanguage
    @rename(attribute: "preferred_language_for_exam")
  currentProvince: LocalizedProvinceOrTerritory
    @rename(attribute: "current_province")
  currentCity: String @rename(attribute: "current_city")
  citizenship: LocalizedCitizenshipStatus
  armedForcesStatus: LocalizedArmedForcesStatus
    @rename(attribute: "armed_forces_status")

  # Language
  lookingForEnglish: Boolean @rename(attribute: "looking_for_english")
  lookingForFrench: Boolean @rename(attribute: "looking_for_french")
  lookingForBilingual: Boolean @rename(attribute: "looking_for_bilingual")
  firstOfficialLanguage: LocalizedLanguage
    @rename(attribute: "first_official_language")
  secondLanguageExamCompleted: Boolean
    @rename(attribute: "second_language_exam_completed")
  secondLanguageExamValidity: Boolean
    @rename(attribute: "second_language_exam_validity")
  comprehensionLevel: LocalizedEvaluatedLanguageAbility
    @rename(attribute: "comprehension_level")
  writtenLevel: LocalizedEvaluatedLanguageAbility
    @rename(attribute: "written_level")
  verbalLevel: LocalizedEvaluatedLanguageAbility
    @rename(attribute: "verbal_level")
  estimatedLanguageAbility: LocalizedEstimatedLanguageAbility
    @rename(attribute: "estimated_language_ability")

  # Gov info
  isGovEmployee: Boolean @rename(attribute: "is_gov_employee")
  govEmployeeType: LocalizedGovEmployeeType
    @rename(attribute: "gov_employee_type")
  currentClassification: Classification @belongsTo # Users current classification
  department: Department @belongsTo
  hasPriorityEntitlement: Boolean @rename(attribute: "has_priority_entitlement")
  priorityNumber: String @rename(attribute: "priority_number")

  # Employment equity
  isWoman: Boolean @rename(attribute: "is_woman")
  hasDisability: Boolean @rename(attribute: "has_disability")
  isVisibleMinority: Boolean @rename(attribute: "is_visible_minority")
  indigenousCommunities: [LocalizedIndigenousCommunity]
    @rename(attribute: "indigenous_communities")
  indigenousDeclarationSignature: String
    @rename(attribute: "indigenous_declaration_signature")

  # Applicant info
  hasDiploma: Boolean
    @rename(attribute: "has_diploma")
    @deprecated(reason: "hasDiploma to be replaced")
  locationPreferences: [LocalizedWorkRegion]
    @rename(attribute: "location_preferences")
  locationExemptions: String @rename(attribute: "location_exemptions")
  acceptedOperationalRequirements: [LocalizedOperationalRequirement]
    @rename(attribute: "accepted_operational_requirements")
  positionDuration: [PositionDuration] @rename(attribute: "position_duration")

  # Pool info
  poolCandidates: [PoolCandidate]
    @hasMany(scopes: ["authorizedToView"])
    @canResolved(ability: "view") # PoolCandidate objects associate the user with a pool
  # Experiences
  experiences: [Experience] @belongsToMany # All experiences that a user owns
  awardExperiences: [AwardExperience] @belongsToMany # Award experiences that a user owns
  communityExperiences: [CommunityExperience] @belongsToMany # Community experiences that a user owns
  educationExperiences: [EducationExperience] @belongsToMany # Education experiences that a user owns
  personalExperiences: [PersonalExperience] @belongsToMany # Personal experiences that a user owns
  workExperiences: [WorkExperience] @belongsToMany # Work experiences that a user owns
  # Skill Library
  userSkills(includeSkillIds: [UUID] @in(key: "skill_id")): [UserSkill] @hasMany
  topTechnicalSkillsRanking: [UserSkill] @with(relation: "userSkills")
  topBehaviouralSkillsRanking: [UserSkill] @with(relation: "userSkills")
  improveTechnicalSkillsRanking: [UserSkill] @with(relation: "userSkills")
  improveBehaviouralSkillsRanking: [UserSkill] @with(relation: "userSkills")
  # Profile Status
  isProfileComplete: Boolean
  priorityWeight: Int @rename(attribute: "priority_weight")
  priority: LocalizedPriorityWeight
  # authorization and roles
  authInfo: UserAuthInfo @self
  # site options
  enabledEmailNotifications: [NotificationFamily]
    @rename(attribute: "enabled_email_notifications")
  enabledInAppNotifications: [NotificationFamily]
    @rename(attribute: "enabled_in_app_notifications")

  # Bookmarks
  poolBookmarks: [Pool] @belongsToMany
}

interface Notification {
  id: ID!
  readAt: DateTime @rename(attribute: "read_at")
  createdAt: DateTime! @rename(attribute: "created_at")
  updatedAt: DateTime! @rename(attribute: "updated_at")
}

type TestNotification implements Notification {
  id: ID!
  readAt: DateTime @rename(attribute: "read_at")
  createdAt: DateTime! @rename(attribute: "created_at")
  updatedAt: DateTime! @rename(attribute: "updated_at")

  name: String
}

type ApplicationDeadlineApproachingNotification implements Notification {
  id: ID!
  readAt: DateTime @rename(attribute: "read_at")
  createdAt: DateTime! @rename(attribute: "created_at")
  updatedAt: DateTime! @rename(attribute: "updated_at")

  closingDate: Date
  poolName: LocalizedString
  poolId: ID
  poolCandidateId: ID
}

type NewJobPostedNotification implements Notification {
  id: ID!
  readAt: DateTime @rename(attribute: "read_at")
  createdAt: DateTime! @rename(attribute: "created_at")
  updatedAt: DateTime! @rename(attribute: "updated_at")

  poolId: ID
}

type ApplicationStatusChangedNotification implements Notification {
  id: ID!
  readAt: DateTime @rename(attribute: "read_at")
  createdAt: DateTime! @rename(attribute: "created_at")
  updatedAt: DateTime! @rename(attribute: "updated_at")

  poolName: LocalizedString
}

type SystemNotification implements Notification {
  id: ID!
  readAt: DateTime @rename(attribute: "read_at")
  createdAt: DateTime! @rename(attribute: "created_at")
  updatedAt: DateTime! @rename(attribute: "updated_at")

  message: LocalizedString
  href: LocalizedString
}

type UserFileGeneratedNotification implements Notification {
  id: ID!
  readAt: DateTime @rename(attribute: "read_at")
  createdAt: DateTime! @rename(attribute: "created_at")
  updatedAt: DateTime! @rename(attribute: "updated_at")

  fileName: String
}

type UserFileGenerationErrorNotification implements Notification {
  id: ID!
  readAt: DateTime @rename(attribute: "read_at")
  createdAt: DateTime! @rename(attribute: "created_at")
  updatedAt: DateTime! @rename(attribute: "updated_at")

  fileName: String
}

type UserPublicProfile @model(class: "\\App\\Models\\User") {
  id: ID!
  email: Email
  firstName: String @rename(attribute: "first_name")
  lastName: String @rename(attribute: "last_name")
}

type GeneralQuestion {
  id: ID!
  pool: Pool @belongsTo
  question: LocalizedString
  sortOrder: Int @rename(attribute: "sort_order")
  # generalQuestionResponses: [GeneralQuestionResponse] @hasMany # TODO: uncomment this and add sensible permission check
}

type ScreeningQuestion {
  id: ID!
  assessmentStep: AssessmentStep @belongsTo @canResolved(ability: "view")
  question: LocalizedString
  sortOrder: Int @rename(attribute: "sort_order")
}

interface HasRoleAssignments {
  id: UUID!
  roleAssignments: [RoleAssignment!]
  teamIdForRoleAssignment: ID # Used to assign roles associated with this resource using the updateUserRoles mutation.
}

type Pool implements HasRoleAssignments {
  id: ID!
  owner: UserPublicProfile @belongsTo(relation: "user")
  team: Team @belongsTo(relation: "legacyTeam") @canModel(ability: "viewAny")
  community: Community @belongsTo(relation: "community")
  name: LocalizedString
  classification: Classification @belongsTo
  operationalRequirements: [LocalizedOperationalRequirement]
    @rename(attribute: "operational_requirements")
  poolCandidates: [PoolCandidate]
    @hasMany(relation: "publishedPoolCandidates", scopes: ["authorizedToView"])
    @canResolved(ability: "view")
    @guard
  poolCandidatesCount: Int
    @count(relation: "poolCandidates", scopes: ["notDraft"])
  keyTasks: LocalizedString @rename(attribute: "key_tasks")
  yourImpact: LocalizedString @rename(attribute: "your_impact")
  whatToExpect: LocalizedString @rename(attribute: "what_to_expect")
  specialNote: LocalizedString @rename(attribute: "special_note")
  whatToExpectAdmission: LocalizedString
    @rename(attribute: "what_to_expect_admission")
  aboutUs: LocalizedString @rename(attribute: "about_us")
  isRemote: Boolean @rename(attribute: "is_remote")
  location: LocalizedString @rename(attribute: "advertisement_location")
  securityClearance: LocalizedSecurityStatus
    @rename(attribute: "security_clearance")
  language: LocalizedPoolLanguage @rename(attribute: "advertisement_language")
  status: LocalizedPoolStatus @rename(attribute: "status")
  stream: LocalizedPoolStream
  processNumber: String @rename(attribute: "process_number")
  publishingGroup: LocalizedPublishingGroup
    @rename(attribute: "publishing_group")
  opportunityLength: LocalizedPoolOpportunityLength
    @rename(attribute: "opportunity_length")
  createdDate: DateTime @rename(attribute: "created_at")
  updatedDate: DateTime @rename(attribute: "updated_at")
  generalQuestions: [GeneralQuestion]
    @hasMany
    @orderBy(column: "sort_order", direction: ASC)
  screeningQuestions: [ScreeningQuestion]
    @hasMany
    @orderBy(column: "sort_order", direction: ASC)
  closingDate: DateTime @rename(attribute: "closing_date")
  closingReason: String @rename(attribute: "closing_reason")
  publishedAt: DateTime @rename(attribute: "published_at")
  archivedAt: DateTime @rename(attribute: "archived_at")
  isComplete: Boolean
  assessmentPlanIsComplete: Boolean
  assessmentSteps: [AssessmentStep]
    @hasMany
    @canRoot(ability: "viewAssessmentPlan")
  poolSkills(type: PoolSkillType @where): [PoolSkill] @hasMany
  roleAssignments: [RoleAssignment!]
    @hasManyThrough
    @canRoot(ability: "viewTeamMembers")
  teamIdForRoleAssignment: ID
  department: Department @belongsTo @canQuery(ability: "view")
}

type GeneralQuestionResponse {
  id: ID!
  answer: String
  generalQuestion: GeneralQuestion @belongsTo
  poolCandidate: PoolCandidate @belongsTo @canResolved(ability: "view")
}

type ScreeningQuestionResponse {
  id: ID!
  answer: String
  screeningQuestion: ScreeningQuestion @belongsTo
}

type AssessmentStep {
  id: ID!
  pool: Pool @belongsTo
  type: LocalizedAssessmentStepType
  sortOrder: Int @rename(attribute: "sort_order")
  title: LocalizedString
  poolSkills: [PoolSkill] @belongsToMany
  assessmentResults: [AssessmentResult]
    @hasMany
    @canRoot(ability: "viewAssessmentResults")
  screeningQuestions: [ScreeningQuestion] @with(relation: "screeningQuestions")
}

type AssessmentResult {
  id: ID!
  assessmentStep: AssessmentStep @belongsTo
  poolCandidate: PoolCandidate @belongsTo
  poolSkill: PoolSkill @belongsTo
  assessmentResultType: AssessmentResultType
    @rename(attribute: "assessment_result_type")
  assessmentDecision: LocalizedAssessmentDecision
    @rename(attribute: "assessment_decision")
  justifications: [LocalizedAssessmentResultJustification]
  assessmentDecisionLevel: LocalizedAssessmentDecisionLevel
    @rename(attribute: "assessment_decision_level")
  skillDecisionNotes: String @rename(attribute: "skill_decision_notes")
}

type AssessmentStepDecision {
  step: UUID!
  decision: AssessmentDecision
}

type AssessmentResultStatus {
  assessmentStepStatuses: [AssessmentStepDecision]
  overallAssessmentStatus: OverallAssessmentStatus
  currentStep: Int # Starts at 1, null indicates all steps successful
}

type PoolSkill {
  id: ID!
  type: LocalizedPoolSkillType
  requiredLevel: SkillLevel @rename(attribute: "required_skill_level")
  skill: Skill @belongsTo
  assessmentSteps: [AssessmentStep]
    @belongsToMany
    @canRoot(ability: "viewAssessmentSteps")
}

type PoolCandidate {
  id: ID!
  pool: Pool! @belongsTo @canResolved(ability: "view")
  user: User! @belongsTo(relation: "user") @canResolved(ability: "view")
  # Expiry date for this candidate being in the pool.
  expiryDate: Date @rename(attribute: "expiry_date")

  status: LocalizedPoolCandidateStatus
    @rename(attribute: "pool_candidate_status")
    @canRoot(ability: "viewStatus")
  statusWeight: Int
    @rename(attribute: "status_weight")
    @canRoot(ability: "viewStatus")
  notes: String @canRoot(ability: "viewNotes")
  archivedAt: DateTime @rename(attribute: "archived_at")
  submittedAt: DateTime @rename(attribute: "submitted_at")
  suspendedAt: DateTime @rename(attribute: "suspended_at")
  deletedDate: DateTime @rename(attribute: "deleted_at")
  isBookmarked: Boolean
    @rename(attribute: "is_bookmarked")
    @canRoot(ability: "viewNotes")
  removedAt: DateTime
    @rename(attribute: "removed_at")
    @canRoot(ability: "viewStatus")
  removalReason: LocalizedCandidateRemovalReason
    @rename(attribute: "removal_reason")
    @canRoot(ability: "viewStatus")
  removalReasonOther: String
    @rename(attribute: "removal_reason_other")
    @canRoot(ability: "viewStatus")

  profileSnapshot: JSON @rename(attribute: "profile_snapshot")
  signature: String
  submittedSteps: [ApplicationStep!] @rename(attribute: "submitted_steps")
  generalQuestionResponses: [GeneralQuestionResponse] @hasMany
  screeningQuestionResponses: [ScreeningQuestionResponse] @hasMany
  educationRequirementOption: LocalizedEducationRequirementOption
    @rename(attribute: "education_requirement_option") # associated experiences to fulfill this called educationRequirementExperiences
  educationRequirementExperiences: [Experience] @belongsToMany
  # record of decision
  assessmentResults: [AssessmentResult]
    @hasMany
    @canRoot(ability: "viewAssessment")
  assessmentStatus: AssessmentResultStatus
    @rename(attribute: "computed_assessment_status")
  finalDecision: LocalizedFinalDecision
    @rename(attribute: "computed_final_decision")
  finalDecisionAt: DateTime
    @rename(attribute: "final_decision_at")
    @canRoot(ability: "viewStatus")
  placedAt: DateTime
    @rename(attribute: "placed_at")
    @canRoot(ability: "viewStatus")
  placedDepartment: Department @belongsTo @canRoot(ability: "viewStatus")

  # claim verification
  veteranVerification: ClaimVerificationResult
    @rename(attribute: "veteran_verification")
    @canRoot(ability: "viewNotes")
  veteranVerificationExpiry: Date
    @rename(attribute: "veteran_verification_expiry")
    @canRoot(ability: "viewNotes")
  priorityVerification: ClaimVerificationResult
    @rename(attribute: "priority_verification")
    @canRoot(ability: "viewNotes")
  priorityVerificationExpiry: Date
    @rename(attribute: "priority_verification_expiry")
    @canRoot(ability: "viewNotes")
}

type PoolCandidateWithSkillCount {
  id: ID!
  poolCandidate: PoolCandidate! @self
  skillCount: Int @rename(attribute: "skill_count") # will always be null unless used with skillsAdditive or skillsIntersectional scope
}

type Classification {
  id: ID!
  name: LocalizedString
  group: String!
  level: Int!
  minSalary: Int @rename(attribute: "min_salary")
  maxSalary: Int @rename(attribute: "max_salary")
  genericJobTitles: [GenericJobTitle] @belongsToMany
}

type GenericJobTitle {
  id: ID!
  key: GenericJobTitleKey!
  name: LocalizedString
  classification: Classification @belongsTo
}

type Department {
  id: ID!
  departmentNumber: Int! @rename(attribute: "department_number")
  name: LocalizedString!
  teams: [Team] @belongsToMany @canModel(ability: "viewAny")
  pools: [Pool]
    @hasMany(scopes: ["authorizedToView"])
    @canResolved(ability: "view")
}

type Community implements HasRoleAssignments {
  id: ID!
  key: String!
  name: LocalizedString
  description: LocalizedString
  roleAssignments: [RoleAssignment!]
    @hasManyThrough
    @canRoot(ability: "viewTeamMembers")
  teamIdForRoleAssignment: ID
  pools: [Pool]
    @hasMany(scopes: ["authorizedToView"])
    @canResolved(ability: "view")
}

type Team implements HasRoleAssignments {
  id: ID!
  name: String! # represents a unique key for a team
  displayName: LocalizedString @rename(attribute: "display_name")
  description: LocalizedString
  departments: [Department] @belongsToMany
  contactEmail: Email @rename(attribute: "contact_email")
  pools: [Pool] @hasMany @canResolved(ability: "view")
  teamable: HasRoleAssignments @morphTo @canRoot(ability: "viewTeamable")
  roleAssignments: [RoleAssignment!]
    @hasMany
    @canRoot(ability: "viewTeamMembers")
  teamIdForRoleAssignment: ID @rename(attribute: "id")
}

type Role {
  id: ID!
  name: String! # represents a unique key for a role
  displayName: LocalizedString @rename(attribute: "display_name")
  description: LocalizedString
  isTeamBased: Boolean @rename(attribute: "is_team_based")
  roleAssignments: [RoleAssignment!]
    @hasMany
    @canModel(ability: "viewAnyRoleAssignments", model: "Role")
}

# This model represents the polymorphic role_user table and allows querying the team relationship
type RoleAssignment {
  id: ID!
  role: Role @belongsTo
  teamable: HasRoleAssignments # Returns the related team, if it has a teamable returns that instead
  team: Team @belongsTo
  user: UserPublicProfile @morphTo
}

# equity selections goes with the pool/applicant filters and not user model
type EquitySelections {
  isWoman: Boolean @rename(attribute: "is_woman")
  hasDisability: Boolean @rename(attribute: "has_disability")
  isIndigenous: Boolean @rename(attribute: "is_indigenous")
  isVisibleMinority: Boolean @rename(attribute: "is_visible_minority")
}

input EquitySelectionsInput {
  isWoman: Boolean @rename(attribute: "is_woman")
  hasDisability: Boolean @rename(attribute: "has_disability")
  isVisibleMinority: Boolean @rename(attribute: "is_visible_minority")
  isIndigenous: Boolean @rename(attribute: "is_indigenous")
}

type PoolCandidateFilter {
  id: ID!
  classifications: [Classification] @belongsToMany
  hasDiploma: Boolean
    @rename(attribute: "has_diploma")
    @deprecated(reason: "hasDiploma to be replaced")
  equity: EquitySelections
  languageAbility: LocalizedLanguageAbility
    @rename(attribute: "language_ability")
  operationalRequirements: [LocalizedOperationalRequirement]
    @rename(attribute: "operational_requirements")
  workRegions: [LocalizedWorkRegion] @rename(attribute: "work_regions")
  pools: [Pool] @belongsToMany @canResolved(ability: "view")
}

# ApplicantFilter only includes the fields which Talent Seekers can use to search for candidates.
type ApplicantFilter {
  id: ID!
  hasDiploma: Boolean
    @rename(attribute: "has_diploma")
    @deprecated(reason: "hasDiploma to be replaced")
  equity: EquitySelections
  languageAbility: LocalizedLanguageAbility
    @rename(attribute: "language_ability")
  operationalRequirements: [LocalizedOperationalRequirement]
    @rename(attribute: "operational_requirements")
  locationPreferences: [LocalizedWorkRegion]
    @rename(attribute: "location_preferences")
  positionDuration: [PositionDuration] @rename(attribute: "position_duration")
  skills: [Skill] @belongsToMany
  # request creation connects to qualifiedClassifications
  qualifiedClassifications: [Classification] @belongsToMany # Filters applicants based on the classifications pools they've qualified in.
  qualifiedStreams: [LocalizedPoolStream]
    @rename(attribute: "qualified_streams") # Filters applicants based on the streams of the pools they've qualified in.
  pools: [Pool] @belongsToMany @canResolved(ability: "view")
  community: Community @belongsTo # Currently does not affect search, scope needs to be added
}

type PoolCandidateSearchRequest {
  id: ID!
  fullName: String @rename(attribute: "full_name")
  email: Email
  department: Department @belongsTo
  jobTitle: String @rename(attribute: "job_title")
  additionalComments: String @rename(attribute: "additional_comments")
  hrAdvisorEmail: Email @rename(attribute: "hr_advisor_email")
  requestedDate: DateTime @rename(attribute: "created_at")
  status: LocalizedPoolCandidateSearchStatus
    @rename(attribute: "request_status")
  statusChangedAt: DateTime @rename(attribute: "request_status_changed_at")
  adminNotes: String @rename(attribute: "admin_notes")
  poolCandidateFilter: PoolCandidateFilter
    @belongsTo
    @deprecated(reason: "Replaced by applicantFilter")
  applicantFilter: ApplicantFilter @belongsTo
  wasEmpty: Boolean @rename(attribute: "was_empty")
  managerJobTitle: String @rename(attribute: "manager_job_title")
  positionType: LocalizedPoolCandidateSearchPositionType
    @rename(attribute: "position_type")
  reason: LocalizedPoolCandidateSearchRequestReason
  community: Community @belongsTo
}

type SkillFamily {
  id: ID!
  key: KeyString!
  name: LocalizedString
  description: LocalizedString
  skills: [Skill!] @belongsToMany
}

type Skill {
  id: ID!
  key: KeyString!
  name: LocalizedString!
  description: LocalizedString
  keywords: SkillKeywords
  category: LocalizedSkillCategory!
  families: [SkillFamily!] @belongsToMany

  # ExperienceSkillRecord is the pivot data and may only be queried when Skill is nested in an Experience (eg. experience->skill->experienceSkillRecord). Querying for it otherwise will just return null.
  experienceSkillRecord: ExperienceSkillRecord
    @rename(attribute: "experience_skill")
}

type UserSkill {
  id: ID!
  user: User! @belongsTo @canResolved(ability: "view")
  skill: Skill! @belongsTo
  skillLevel: SkillLevel @rename(attribute: "skill_level")
  whenSkillUsed: WhenSkillUsed @rename(attribute: "when_skill_used")
  topSkillsRank: Int @rename(attribute: "top_skills_rank")
  improveSkillsRank: Int @rename(attribute: "improve_skills_rank")
  # Experiences
  experiences: [Experience!] @belongsToMany
}

type SkillKeywords {
  en: [String!]
  fr: [String!]
}

interface Experience {
  id: ID!
  user: User! @belongsTo(relation: "user") @canResolved(ability: "view")
  details: String
  skills: [Skill!] @hasMany
  # ExperienceSkillRecord is the pivot data and may only be queried when Experience is nested in a Skill (eg. skill->experiences->experienceSkillRecord). Querying for it otherwise will just return null.
  experienceSkillRecord: ExperienceSkillRecord
    @rename(attribute: "experience_skill")
  deletedDate: DateTime @rename(attribute: "deleted_at")
}

type WorkExperience implements Experience {
  id: ID!
  user: User! @belongsTo(relation: "user") @canResolved(ability: "view")
  role: String
  organization: String
  division: String
  startDate: Date @rename(attribute: "start_date")
  endDate: Date @rename(attribute: "end_date")
  details: String
  skills: [Skill!] @hasMany
  # ExperienceSkillRecord is the pivot data and may only be queried when Experience is nested in a Skill (eg. skill->experiences->experienceSkillRecord). Querying for it otherwise will just return null.
  experienceSkillRecord: ExperienceSkillRecord
    @rename(attribute: "experience_skill")
  deletedDate: DateTime @rename(attribute: "deleted_at")
}
type PersonalExperience implements Experience {
  id: ID!
  user: User! @belongsTo(relation: "user") @canResolved(ability: "view")
  title: String
  description: String
  startDate: Date @rename(attribute: "start_date")
  endDate: Date @rename(attribute: "end_date")
  details: String
  skills: [Skill!] @hasMany
  # ExperienceSkillRecord is the pivot data and may only be queried when Experience is nested in a Skill (eg. skill->experiences->experienceSkillRecord). Querying for it otherwise will just return null.
  experienceSkillRecord: ExperienceSkillRecord
    @rename(attribute: "experience_skill")
  deletedDate: DateTime @rename(attribute: "deleted_at")
}
type CommunityExperience implements Experience {
  id: ID!
  user: User! @belongsTo(relation: "user") @canResolved(ability: "view")
  title: String
  organization: String
  project: String
  startDate: Date @rename(attribute: "start_date")
  endDate: Date @rename(attribute: "end_date")
  details: String
  skills: [Skill!] @hasMany
  # ExperienceSkillRecord is the pivot data and must be queried through a nested mutation (eg. experience->skill->experienceSkillRecord) querying for it directly will just return null
  experienceSkillRecord: ExperienceSkillRecord
    @rename(attribute: "experience_skill")
  deletedDate: DateTime @rename(attribute: "deleted_at")
}
type EducationExperience implements Experience {
  id: ID!
  user: User! @belongsTo(relation: "user") @canResolved(ability: "view")
  institution: String
  areaOfStudy: String @rename(attribute: "area_of_study")
  thesisTitle: String @rename(attribute: "thesis_title")
  startDate: Date @rename(attribute: "start_date")
  endDate: Date @rename(attribute: "end_date")
  type: LocalizedEducationType
  status: LocalizedEducationStatus
  details: String
  skills: [Skill!] @hasMany
  # ExperienceSkillRecord is the pivot data and may only be queried when Experience is nested in a Skill (eg. skill->experiences->experienceSkillRecord). Querying for it otherwise will just return null.
  experienceSkillRecord: ExperienceSkillRecord
    @rename(attribute: "experience_skill")
  deletedDate: DateTime @rename(attribute: "deleted_at")
}
type AwardExperience implements Experience {
  id: ID!
  user: User! @belongsTo(relation: "user") @canResolved(ability: "view")
  title: String
  issuedBy: String @rename(attribute: "issued_by")
  awardedDate: Date @rename(attribute: "awarded_date")
  awardedTo: LocalizedAwardedTo @rename(attribute: "awarded_to")
  awardedScope: LocalizedAwardedScope @rename(attribute: "awarded_scope")
  details: String
  skills: [Skill!] @hasMany
  # ExperienceSkillRecord is the pivot data and may only be queried when Experience is nested in a Skill (eg. skill->experiences->experienceSkillRecord). Querying for it otherwise will just return null.
  experienceSkillRecord: ExperienceSkillRecord
    @rename(attribute: "experience_skill")
  deletedDate: DateTime @rename(attribute: "deleted_at")
}

type ExperienceSkillRecord {
  details: String
}

input ClassificationFilterInput {
  group: String!
  level: Int!
}

input KeyFilterInput {
  key: KeyString!
}

input IdInput {
  id: ID!
}

input UserPoolFilterInput {
  poolId: ID!
  expiryStatus: CandidateExpiryFilter = ACTIVE
  statuses: [PoolCandidateStatus!]
  suspendedStatus: CandidateSuspendedFilter = ACTIVE
}

input UserFilterInput {
  applicantFilter: ApplicantFilterInput @spread
  poolFilters: [UserPoolFilterInput] @scope(name: "poolFilters")
  isProfileComplete: Boolean @scope
  isGovEmployee: Boolean @scope
  telephone: String @scope
  email: String @scope
  name: String @scope
  generalSearch: String @scope
  roles: [ID] @scope(name: "roleAssignments")
  trashed: Trashed @trashed
}

input UserPublicProfileFilterInput {
  publicProfileSearch: String @scope
}

input PoolFilterInput {
  generalSearch: String @scope
  name: String @scope
  team: String @scope
  streams: [PoolStream!] @scope
  statuses: [PoolStatus!] = [] @scope
  processNumber: String @scope
  publishingGroups: [PublishingGroup!] @scope
  classifications: [ClassificationFilterInput!] @scope
  canAdmin: Boolean @scope
}

input PoolTeamDisplayNameOrderByInput {
  locale: String!
  order: SortOrder!
}

input PoolBookmarksOrderByInput {
  column: String!
  order: SortOrder!
}

# Changes to this input will require some manual updates to api/app/GraphQL/Queries/CountPoolCandidatesByPool.php since it doesn't use the directives for automatic resolution
input ApplicantFilterInput {
  equity: EquitySelectionsInput @scope
  hasDiploma: Boolean @scope @deprecated(reason: "hasDiploma to be replaced")
  languageAbility: LanguageAbility @scope
  locationPreferences: [WorkRegion] @scope
  operationalRequirements: [OperationalRequirement] @scope
  positionDuration: [PositionDuration] @scope
  # This field is [IdInput] instead of [ID] so that the output of an ApplicantFilter query can be used directly.
  pools: [IdInput] @scope(name: "availableInPools") @pluck(key: "id")
  skills: [IdInput] @scope(name: "skillsAdditive") @pluck(key: "id") # main one to correspond with ApplicantFilter.php
  skillsIntersectional: [IdInput] @scope @pluck(key: "id") # AND filtering skills as opposed to OR
  qualifiedClassifications: [ClassificationFilterInput]
    @scope(name: "qualifiedClassifications") # Filters applicants based on the classification of pools they are currently qualified and available in.
  qualifiedStreams: [PoolStream] @scope(name: "qualifiedStreams") # Filters applicants based on the stream of pools they are currently qualified and available in.
  community: IdInput @scope(name: "candidatesInCommunity") @pluck(key: "id")
}

input PoolCandidateSearchInput {
  applicantFilter: ApplicantFilterInput @spread
  email: String @scope
  generalSearch: String @scope
  name: String @scope
  notes: String @scope
  isGovEmployee: Boolean @scope
  priorityWeight: [PriorityWeight] @scope(name: "candidateCategory")
  poolCandidateStatus: [PoolCandidateStatus]
    @scope(name: "poolCandidateStatuses")
  expiryStatus: CandidateExpiryFilter @scope(name: "expiryStatus")
  suspendedStatus: CandidateSuspendedFilter @scope(name: "suspendedStatus")
  publishingGroups: [PublishingGroup] @scope(name: "publishingGroups") # Filters applicants based on the publishing group of the pool
  # Filters applicants based on the classification of all pools they are currently in.
  # There is also a classification field as part of ApplicantFilterInput however it includes scoping for availability.
  appliedClassifications: [ClassificationFilterInput]
    @scope(name: "appliedClassifications")
  processNumber: String @scope(name: "processNumber")
}


input PoolCandidateSearchRequestInput {
  status: [PoolCandidateSearchStatus] @scope(name: "searchRequestStatus")
  departments: [ID] @scope
  classifications: [ID] @scope
  streams: [PoolStream] @scope
  fullName: String @scope
  email: String @scope
  id: ID @scope
  jobTitle: String @scope
  additionalComments: String @scope
  hrAdvisorEmail: String @scope
  adminNotes: String @scope
  generalSearch: String @scope
}

input PoolCandidatePoolNameOrderByInput {
  locale: String!
  order: SortOrder!
}

type CandidateSearchPoolResult {
  pool: Pool! @canResolved(ability: "view")
  candidateCount: Int! @rename(attribute: "candidate_count")
}

type SitewideAnnouncement {
  isEnabled: Boolean!
  publishDate: DateTime!
  expiryDate: DateTime!
  title: LocalizedString!
  message: LocalizedString!
}

input SitewideAnnouncementInput {
  isEnabled: Boolean!
  publishDate: DateTime!
  expiryDate: DateTime! @rules(apply: ["after:publishDate"])
  title: LocalizedStringInput!
  message: LocalizedStringInput!
}

type Query {
  myAuth: UserAuthInfo @auth
  me: User @auth
  user(id: UUID! @eq): User @find @softDeletes @guard @canQuery(ability: "view")
  usersPaginated(
    where: UserFilterInput
    orderBy: [OrderByClause!] @orderBy
  ): [User]!
    @orderBy(column: "created_at", direction: DESC)
    @paginate(defaultCount: 10, maxCount: 1000, scopes: ["authorizedToView"])
    @guard
    @canResolved(ability: "view")
  applicants(includeIds: [ID]! @in(key: "id")): [User]!
    @all(model: "User")
    @guard
    @canModel(ability: "viewAny", model: "User")
    @deprecated(
      reason: "applicants is deprecated. Use usersPaginated instead. Remove in #7652."
    )
  userPublicProfilesPaginated(
    where: UserPublicProfileFilterInput
    excludeIds: [ID!] @notIn(key: "id")
    orderBy: [OrderByClause!] @orderBy
  ): [UserPublicProfile]!
    @orderBy(column: "created_at", direction: DESC)
    @paginate(
      defaultCount: 10
      maxCount: 1000
      scopes: ["authorizedToViewBasicInfo"]
    )
    @guard
    @canModel(ability: "viewBasicInfo", model: "User")
  # countApplicants returns the number of candidates matching its filters, and requires no special permissions.
  countApplicants(where: ApplicantFilterInput): Int!
    @count(model: "User", scopes: ["talentSearchablePublishingGroup"])
  pool(id: UUID! @eq): Pool @find @canQuery(ability: "view")
  publishedPools(
    closingAfter: DateTime @where(key: "closing_date", operator: ">")
    publishingGroup: PublishingGroup
      @where(key: "publishing_group", operator: "=")
  ): [Pool!]!
    @all(scopes: ["wasPublished", "notArchived"])
    @canModel(ability: "viewAnyPublished", model: "Pool")
  pools: [Pool]!
    @all(scopes: ["authorizedToView", "notArchived"])
    @canResolved(ability: "view")
    @deprecated(reason: "pools is deprecated. Use poolsPaginated instead.")
  poolsPaginated(
    includeIds: [UUID!] @in(key: "id")
    excludeIds: [UUID!] @notIn(key: "id")
    where: PoolFilterInput
    orderByPoolBookmarks: PoolBookmarksOrderByInput @scope
    orderByTeamDisplayName: PoolTeamDisplayNameOrderByInput @scope
    orderBy: _
      @orderBy(
        relations: [
          { relation: "user", columns: ["first_name", "email"] }
          { relation: "classification", columns: ["group", "level"] }
        ]
      )
  ): [Pool]!
    @paginate(defaultCount: 10, maxCount: 1000, scopes: ["authorizedToView"])
    @canResolved(ability: "view")
  poolCandidate(id: UUID! @eq): PoolCandidate
    @find
    @guard
    @canQuery(ability: "view")
  poolCandidates(includeIds: [ID]! @in(key: "id")): [PoolCandidate]!
    @all(scopes: ["notDraft"])
    @guard
    @canResolved(ability: "view")
    @deprecated(
      reason: "poolCandidates is deprecated. Use poolCandidatesPaginated instead. Remove in #7656."
    )
  poolCandidatesPaginated(
    where: PoolCandidateSearchInput
    orderByPoolName: PoolCandidatePoolNameOrderByInput @scope
    orderByClaimVerification: SortOrder @scope
    orderBy: _
      @orderBy(
        relations: [
          {
            relation: "user"
            columns: [
              "priority_weight"
              "first_name"
              "email"
              "preferred_lang"
              "preferred_language_for_interview"
              "preferred_language_for_exam"
              "current_city"
            ]
          }
          { relation: "pool", columns: ["process_number"] }
        ]
      )
  ): [PoolCandidateWithSkillCount]!
    @guard
    @paginate(
      defaultCount: 10
      maxCount: 1000
      scopes: ["notDraft", "withSkillCount", "authorizedToView"]
      model: "App\\Models\\PoolCandidate"
    )
  # This query lives at api/app/GraphQL/Queries/CountPoolCandidatesByPool.php.
  # Returns the number of candidates by filtering their parent applicant, grouped by pool.
  countPoolCandidatesByPool(
    where: ApplicantFilterInput
  ): [CandidateSearchPoolResult!]!
  classification(id: UUID! @eq): Classification @find @canModel(ability: "view")
  classifications: [Classification]! @all @canModel(ability: "viewAny")
  department(id: UUID! @eq): Department @find @canModel(ability: "view")
  departments: [Department]! @all @canModel(ability: "viewAny")
  poolCandidateSearchRequest(id: ID! @eq): PoolCandidateSearchRequest
    @find
    @guard
    @canQuery(ability: "view")
  poolCandidateSearchRequestsPaginated(
    where: PoolCandidateSearchRequestInput
    orderBy: [OrderByClause!] @orderBy
  ): [PoolCandidateSearchRequest]!
    @orderBy(column: "created_at", direction: DESC)
    @paginate(defaultCount: 10, maxCount: 500, scopes: ["authorizedToView"])
    @guard
    @canResolved(ability: "view")
  skillFamily(id: UUID! @eq): SkillFamily @find @canModel(ability: "view")
  skillFamilies: [SkillFamily]! @all @canModel(ability: "viewAny")
  skill(id: UUID! @eq): Skill @find @canModel(ability: "view")
  skills: [Skill]! @all @canModel(ability: "viewAny")
  genericJobTitle(id: UUID! @eq): GenericJobTitle
    @find
    @canModel(ability: "view")
  genericJobTitles: [GenericJobTitle]! @all @canModel(ability: "viewAny")

  community(id: UUID! @eq): Community @find @canQuery(ability: "view")
  communities: [Community]! @all @canModel(ability: "viewAny")
  team(id: UUID! @eq): Team @find @canQuery(ability: "view")
  teams: [Team]! @all @canModel(ability: "viewAny")
  roles: [Role]! @all @canModel(ability: "viewAny")

  notifications(
    where: NotificationFilterInput
    excludeIds: [UUID!] @notIn(key: "id")
  ): [Notification!]
    @orderBy(column: "created_at", direction: DESC)
    @paginate(defaultCount: 10, scopes: ["authorizedToView"])

  sitewideAnnouncement: SitewideAnnouncement

  localizedEnumStrings(
    enumName: String!
      @rules(apply: ["required", "App\\Rules\\LocalizedEnumExists"])
  ): [LocalizedEnumString!]
}

input ClassificationBelongsTo {
  connect: ID
  disconnect: Boolean
}
input PoolsHasMany {
  create: [CreatePoolInput]
}
"""
When creating a User, name is required.
"""
input CreateUserInput {
  sub: String
    @rules(
      apply: ["sometimes", "unique:users,sub"]
      messages: [{ rule: "unique", message: "CreateUserSubInUse" }]
    )

  # Personal info
  firstName: String! @rename(attribute: "first_name")
  lastName: String! @rename(attribute: "last_name")
  email: Email
    @lowerCase
    @rules(
      apply: ["sometimes", "nullable", "unique:users,email"]
      messages: [{ rule: "unique", message: "CreateUserEmailInUse" }]
    )
  telephone: PhoneNumber
  preferredLang: Language @rename(attribute: "preferred_lang")
  preferredLanguageForInterview: Language
    @rename(attribute: "preferred_language_for_interview")
  preferredLanguageForExam: Language
    @rename(attribute: "preferred_language_for_exam")
  currentProvince: ProvinceOrTerritory @rename(attribute: "current_province")
  currentCity: String @rename(attribute: "current_city")
  citizenship: CitizenshipStatus
  armedForcesStatus: ArmedForcesStatus @rename(attribute: "armed_forces_status")

  # Language
  lookingForEnglish: Boolean @rename(attribute: "looking_for_english")
  lookingForFrench: Boolean @rename(attribute: "looking_for_french")
  lookingForBilingual: Boolean @rename(attribute: "looking_for_bilingual")
  firstOfficialLanguage: Language @rename(attribute: "first_official_language")
  secondLanguageExamCompleted: Boolean
    @rename(attribute: "second_language_exam_completed")
  secondLanguageExamValidity: Boolean
    @rename(attribute: "second_language_exam_validity")
  comprehensionLevel: EvaluatedLanguageAbility
    @rename(attribute: "comprehension_level")
  writtenLevel: EvaluatedLanguageAbility @rename(attribute: "written_level")
  verbalLevel: EvaluatedLanguageAbility @rename(attribute: "verbal_level")
  estimatedLanguageAbility: EstimatedLanguageAbility
    @rename(attribute: "estimated_language_ability")

  # Gov info
  isGovEmployee: Boolean @rename(attribute: "is_gov_employee")
  govEmployeeType: GovEmployeeType @rename(attribute: "gov_employee_type")
  currentClassification: ClassificationBelongsTo
  department: DepartmentBelongsTo
  hasPriorityEntitlement: Boolean @rename(attribute: "has_priority_entitlement")
  priorityNumber: String @rename(attribute: "priority_number")

  # Employment equity
  isWoman: Boolean @rename(attribute: "is_woman")
  hasDisability: Boolean @rename(attribute: "has_disability")
  isVisibleMinority: Boolean @rename(attribute: "is_visible_minority")
  indigenousCommunities: [IndigenousCommunity]
    @rename(attribute: "indigenous_communities")
  indigenousDeclarationSignature: String
    @rename(attribute: "indigenous_declaration_signature")

  # Applicant info
  hasDiploma: Boolean
    @rename(attribute: "has_diploma")
    @deprecated(reason: "hasDiploma to be replaced")
  locationPreferences: [WorkRegion] @rename(attribute: "location_preferences")
  locationExemptions: String @rename(attribute: "location_exemptions")
  acceptedOperationalRequirements: [OperationalRequirement]
    @rename(attribute: "accepted_operational_requirements")
  positionDuration: [PositionDuration] @rename(attribute: "position_duration")

  # Experiences
  workExperiences: WorkExperienceHasMany
  personalExperiences: PersonalExperienceHasMany
  communityExperiences: CommunityExperienceHasMany
  educationExperiences: EducationExperienceHasMany
  awardExperiences: AwardExperienceHasMany
}
"""
When updating a User, all fields are optional
"""
input UpdateUserAsAdminInput
  @validator(class: "App\\GraphQL\\Validators\\UpdateUserInputValidator") {
  id: ID

  # Personal info
  email: Email @lowerCase
  firstName: String @rename(attribute: "first_name")
  lastName: String @rename(attribute: "last_name")
  telephone: PhoneNumber
  preferredLang: Language @rename(attribute: "preferred_lang")
  preferredLanguageForInterview: Language
    @rename(attribute: "preferred_language_for_interview")
  preferredLanguageForExam: Language
    @rename(attribute: "preferred_language_for_exam")
  currentProvince: ProvinceOrTerritory @rename(attribute: "current_province")
  currentCity: String @rename(attribute: "current_city")
  citizenship: CitizenshipStatus
  armedForcesStatus: ArmedForcesStatus @rename(attribute: "armed_forces_status")

  # Language
  lookingForEnglish: Boolean @rename(attribute: "looking_for_english")
  lookingForFrench: Boolean @rename(attribute: "looking_for_french")
  lookingForBilingual: Boolean @rename(attribute: "looking_for_bilingual")
  firstOfficialLanguage: Language @rename(attribute: "first_official_language")
  secondLanguageExamCompleted: Boolean
    @rename(attribute: "second_language_exam_completed")
  secondLanguageExamValidity: Boolean
    @rename(attribute: "second_language_exam_validity")
  comprehensionLevel: EvaluatedLanguageAbility
    @rename(attribute: "comprehension_level")
  writtenLevel: EvaluatedLanguageAbility @rename(attribute: "written_level")
  verbalLevel: EvaluatedLanguageAbility @rename(attribute: "verbal_level")
  estimatedLanguageAbility: EstimatedLanguageAbility
    @rename(attribute: "estimated_language_ability")

  # Gov info
  isGovEmployee: Boolean @rename(attribute: "is_gov_employee")
  govEmployeeType: GovEmployeeType @rename(attribute: "gov_employee_type")
  currentClassification: ClassificationBelongsTo
  department: DepartmentBelongsTo
  hasPriorityEntitlement: Boolean @rename(attribute: "has_priority_entitlement")
  priorityNumber: String @rename(attribute: "priority_number")

  # Employment equity
  isWoman: Boolean @rename(attribute: "is_woman")
  hasDisability: Boolean @rename(attribute: "has_disability")
  isVisibleMinority: Boolean @rename(attribute: "is_visible_minority")
  indigenousCommunities: [IndigenousCommunity]
    @rename(attribute: "indigenous_communities")
  indigenousDeclarationSignature: String
    @rename(attribute: "indigenous_declaration_signature")

  # Applicant info
  hasDiploma: Boolean
    @rename(attribute: "has_diploma")
    @deprecated(reason: "hasDiploma to be replaced")
  locationPreferences: [WorkRegion] @rename(attribute: "location_preferences")
  locationExemptions: String @rename(attribute: "location_exemptions")
  acceptedOperationalRequirements: [OperationalRequirement]
    @rename(attribute: "accepted_operational_requirements")
  positionDuration: [PositionDuration] @rename(attribute: "position_duration")

  # Experiences
  workExperiences: WorkExperienceHasMany
  personalExperiences: PersonalExperienceHasMany
  communityExperiences: CommunityExperienceHasMany
  educationExperiences: EducationExperienceHasMany
  awardExperiences: AwardExperienceHasMany
}

input UpdateUserSubInput {
  userId: UUID! @rename(attribute: "id")
  sub: String!
}

input UpdateUserRolesInput {
  userId: UUID! @rename(attribute: "id")
  roleAssignmentsInput: RoleAssignmentHasMany!
}

input UpdateUserAsUserInput
  @validator(class: "App\\GraphQL\\Validators\\UpdateUserInputValidator") {
  id: ID
  # Personal info
  email: Email @lowerCase
  firstName: String @rename(attribute: "first_name")
  lastName: String @rename(attribute: "last_name")
  telephone: PhoneNumber
  preferredLang: Language @rename(attribute: "preferred_lang")
  preferredLanguageForInterview: Language
    @rename(attribute: "preferred_language_for_interview")
  preferredLanguageForExam: Language
    @rename(attribute: "preferred_language_for_exam")
  currentProvince: ProvinceOrTerritory @rename(attribute: "current_province")
  currentCity: String @rename(attribute: "current_city")
  citizenship: CitizenshipStatus
  armedForcesStatus: ArmedForcesStatus @rename(attribute: "armed_forces_status")

  # Language
  lookingForEnglish: Boolean @rename(attribute: "looking_for_english")
  lookingForFrench: Boolean @rename(attribute: "looking_for_french")
  lookingForBilingual: Boolean @rename(attribute: "looking_for_bilingual")
  firstOfficialLanguage: Language @rename(attribute: "first_official_language")
  secondLanguageExamCompleted: Boolean
    @rename(attribute: "second_language_exam_completed")
  secondLanguageExamValidity: Boolean
    @rename(attribute: "second_language_exam_validity")
  comprehensionLevel: EvaluatedLanguageAbility
    @rename(attribute: "comprehension_level")
  writtenLevel: EvaluatedLanguageAbility @rename(attribute: "written_level")
  verbalLevel: EvaluatedLanguageAbility @rename(attribute: "verbal_level")
  estimatedLanguageAbility: EstimatedLanguageAbility
    @rename(attribute: "estimated_language_ability")

  # Gov info
  isGovEmployee: Boolean @rename(attribute: "is_gov_employee")
  govEmployeeType: GovEmployeeType @rename(attribute: "gov_employee_type")
  currentClassification: ClassificationBelongsTo
  department: DepartmentBelongsTo
  hasPriorityEntitlement: Boolean @rename(attribute: "has_priority_entitlement")
  priorityNumber: String @rename(attribute: "priority_number")

  # Employment equity
  isWoman: Boolean @rename(attribute: "is_woman")
  hasDisability: Boolean @rename(attribute: "has_disability")
  isVisibleMinority: Boolean @rename(attribute: "is_visible_minority")
  indigenousCommunities: [IndigenousCommunity]
    @rename(attribute: "indigenous_communities")
  indigenousDeclarationSignature: String
    @rename(attribute: "indigenous_declaration_signature")

  # Applicant info
  hasDiploma: Boolean
    @rename(attribute: "has_diploma")
    @deprecated(reason: "hasDiploma to be replaced")
  locationPreferences: [WorkRegion] @rename(attribute: "location_preferences")
  locationExemptions: String @rename(attribute: "location_exemptions")
  acceptedOperationalRequirements: [OperationalRequirement]
    @rename(attribute: "accepted_operational_requirements")
  positionDuration: [PositionDuration] @rename(attribute: "position_duration")

  # Experiences
  workExperiences: WorkExperienceHasMany
  personalExperiences: PersonalExperienceHasMany
  communityExperiences: CommunityExperienceHasMany
  educationExperiences: EducationExperienceHasMany
  awardExperiences: AwardExperienceHasMany
}

input LocalizedStringInput {
  en: String
  fr: String
}

input UserBelongsTo {
  connect: ID
}

input PoolBelongsTo {
  connect: ID!
}

input TeamBelongsTo {
  connect: ID!
}

input CreateClassificationInput {
  name: LocalizedStringInput
  group: String!
  level: Int!
  minSalary: Int @rename(attribute: "min_salary")
  maxSalary: Int @rename(attribute: "max_salary")
}

input ClassificationBelongsToMany {
  sync: [ID!]
}

input CreatePoolCandidateAsAdminInput {
  pool: PoolBelongsTo!
  user: UserBelongsTo!
  expiryDate: Date @rename(attribute: "expiry_date")
  status: PoolCandidateStatus = NEW_APPLICATION
    @rename(attribute: "pool_candidate_status")
  notes: String
  isBookmarked: Boolean
}

input UpdateClassificationInput {
  name: LocalizedStringInput
  group: String
  minSalary: Int @rename(attribute: "min_salary")
  maxSalary: Int @rename(attribute: "max_salary")
}

input UpdatePoolCandidateStatusInput {
  expiryDate: Date @rename(attribute: "expiry_date")
  status: PoolCandidateStatus @rename(attribute: "pool_candidate_status")
}

input UpdatePoolCandidateClaimVerificationInput @validator {
  veteranVerification: ClaimVerificationResult
    @rename(attribute: "veteran_verification")
  veteranVerificationExpiry: Date
    @rename(attribute: "veteran_verification_expiry")
  priorityVerification: ClaimVerificationResult
    @rename(attribute: "priority_verification")
  priorityVerificationExpiry: Date
    @rename(attribute: "priority_verification_expiry")
}

input PlaceCandidateInput {
  placementType: PlacementType!
  departmentId: UUID!
}

input CreateDepartmentInput {
  departmentNumber: Int!
    @rename(attribute: "department_number")
    @rules(
      apply: ["unique:departments,department_number"]
      messages: [{ rule: "unique", message: "DepartmentNumberInUse" }]
    )
  name: LocalizedStringInput
}

input UpdateDepartmentInput {
  departmentNumber: Int @rename(attribute: "department_number")
  name: LocalizedStringInput
}

input PoolBelongsToMany {
  sync: [ID!]
}

input DepartmentBelongsTo {
  connect: ID
  disconnect: Boolean
}

input DepartmentBelongsToMany {
  sync: [ID!]
}

input CommunityBelongsTo {
  connect: UUID!
}

input CreateTeamInput {
  name: String!
    @rules(
      apply: ["unique:teams,name"]
      messages: [{ rule: "unique", message: "TeamNameInUse" }]
    )
  displayName: LocalizedStringInput @rename(attribute: "display_name")
  description: LocalizedStringInput
  departments: DepartmentBelongsToMany
  contactEmail: Email @rename(attribute: "contact_email")
}

input UpdateTeamInput {
  name: String
  displayName: LocalizedStringInput @rename(attribute: "display_name")
  description: LocalizedStringInput
  departments: DepartmentBelongsToMany
  contactEmail: Email @rename(attribute: "contact_email")
}

input CreateCommunityInput {
  key: String!
  name: LocalizedStringInput
  description: LocalizedStringInput
}

input UpdateCommunityInput {
  key: String
  name: LocalizedStringInput
  description: LocalizedStringInput
}

input CreateApplicantFilterInput {
  hasDiploma: Boolean
    @rename(attribute: "has_diploma")
    @deprecated(reason: "hasDiploma to be replaced")
  equity: EquitySelectionsInput @spread
  languageAbility: LanguageAbility @rename(attribute: "language_ability")
  operationalRequirements: [OperationalRequirement]
    @rename(attribute: "operational_requirements")
  locationPreferences: [WorkRegion] @rename(attribute: "location_preferences")
  positionDuration: [PositionDuration] @rename(attribute: "position_duration")
  skills: SkillBelongsToMany
  pools: PoolBelongsToMany
  citizenship: CitizenshipStatus
  armedForcesStatus: ArmedForcesStatus @rename(attribute: "armed_forces_status")
  qualifiedClassifications: ClassificationBelongsToMany
  qualifiedStreams: [PoolStream] @rename(attribute: "qualified_streams")
  community: CommunityBelongsTo
}

input ApplicantFilterBelongsTo {
  create: CreateApplicantFilterInput!
}

input CreatePoolCandidateSearchRequestInput {
  fullName: String! @rename(attribute: "full_name")
  email: Email!
  department: DepartmentBelongsTo!
  community: CommunityBelongsTo!
  jobTitle: String! @rename(attribute: "job_title")
  additionalComments: String @rename(attribute: "additional_comments")
  hrAdvisorEmail: Email @rename(attribute: "hr_advisor_email")
  applicantFilter: ApplicantFilterBelongsTo!
  # status will be set to NEW by default in Postgres
  wasEmpty: Boolean @rename(attribute: "was_empty")
  managerJobTitle: String! @rename(attribute: "manager_job_title")
  positionType: PoolCandidateSearchPositionType!
    @rename(attribute: "position_type")
  reason: PoolCandidateSearchRequestReason!
}

input UpdatePoolCandidateSearchRequestInput {
  adminNotes: String @rename(attribute: "admin_notes")
  status: PoolCandidateSearchStatus
  # statusChangedAt updated in the Eloquent model
}

input SkillBelongsToMany {
  sync: [ID!]
}
input SkillBelongsTo {
  connect: ID!
}

input CreateSkillFamilyInput {
  key: KeyString!
    @rules(
      apply: ["unique:skill_families,key"]
      messages: [{ rule: "unique", message: "SkillFamilyKeyStringInUse" }]
    )
  name: LocalizedStringInput!
  description: LocalizedStringInput
  skills: SkillBelongsToMany
}

input UpdateSkillFamilyInput {
  name: LocalizedStringInput
  description: LocalizedStringInput
  skills: SkillBelongsToMany
}

input SkillFamilyBelongsToMany {
  sync: [ID!]
}

input SkillKeywordsInput {
  en: [String!]
  fr: [String!]
}

input CreateSkillInput {
  key: KeyString!
    @rules(
      apply: ["unique:skills,key"]
      messages: [{ rule: "unique", message: "SkillKeyStringInUse" }]
    )
  name: LocalizedStringInput!
  description: LocalizedStringInput
  families: SkillFamilyBelongsToMany
  keywords: SkillKeywordsInput
  category: SkillCategory!
}

input UpdateSkillInput {
  name: LocalizedStringInput!
  description: LocalizedStringInput
  families: SkillFamilyBelongsToMany
  keywords: SkillKeywordsInput
  category: SkillCategory
}

input WorkExperienceInput {
  role: String
  organization: String
  division: String
  startDate: Date @rename(attribute: "start_date")
  endDate: Date @rename(attribute: "end_date")
  details: String
  skills: UpdateExperienceSkills @spread
}
input PersonalExperienceInput {
  title: String
  description: String
  startDate: Date @rename(attribute: "start_date")
  endDate: Date @rename(attribute: "end_date")
  details: String
  skills: UpdateExperienceSkills @spread
}
input CommunityExperienceInput {
  title: String
  organization: String
  project: String
  startDate: Date @rename(attribute: "start_date")
  endDate: Date @rename(attribute: "end_date")
  details: String
  skills: UpdateExperienceSkills @spread
}
input EducationExperienceInput {
  institution: String
  areaOfStudy: String @rename(attribute: "area_of_study")
  thesisTitle: String @rename(attribute: "thesis_title")
  startDate: Date @rename(attribute: "start_date")
  endDate: Date @rename(attribute: "end_date")
  type: EducationType
  status: EducationStatus
  details: String
  skills: UpdateExperienceSkills @spread
}
input AwardExperienceInput {
  title: String
  issuedBy: String @rename(attribute: "issued_by")
  awardedDate: Date @rename(attribute: "awarded_date")
  awardedTo: AwardedTo @rename(attribute: "awarded_to")
  awardedScope: AwardedScope @rename(attribute: "awarded_scope")
  details: String
  skills: UpdateExperienceSkills @spread
}

input UpdateExperienceSkills {
  connect: [ConnectExperienceSkills!] @resolveWith(method: "connectSkills")
  # This is an alias of connect since it is a custom command that can do both (insert and update)
  # It is here to avoid confusion when using it on the frontend
  update: [ConnectExperienceSkills!] @resolveWith(method: "connectSkills")
  disconnect: [ID!] @resolveWith(method: "disconnectSkills")
  sync: [ConnectExperienceSkills!] @resolveWith(method: "syncSkills")
}

input ConnectExperienceSkills {
  id: ID!
  details: String
}

input CreateUserSkillInput {
  skillLevel: SkillLevel @rename(attribute: "skill_level")
  whenSkillUsed: WhenSkillUsed @rename(attribute: "when_skill_used")
}

input UpdateUserSkillInput {
  skillLevel: SkillLevel @rename(attribute: "skill_level")
  whenSkillUsed: WhenSkillUsed @rename(attribute: "when_skill_used")
}

input UpdateUserSkillRankingsInput {
  # array of skill ids
  topTechnicalSkillsRanked: [UUID]
    @rulesForArray(apply: ["nullable", "App\\Rules\\ArrayIsUnique"])
  topBehaviouralSkillsRanked: [UUID]
    @rulesForArray(apply: ["nullable", "App\\Rules\\ArrayIsUnique"])
  improveTechnicalSkillsRanked: [UUID]
    @rulesForArray(apply: ["nullable", "App\\Rules\\ArrayIsUnique"])
  improveBehaviouralSkillsRanked: [UUID]
    @rulesForArray(apply: ["nullable", "App\\Rules\\ArrayIsUnique"])
}

input WorkExperienceHasMany {
  create: [WorkExperienceInput!]
}
input PersonalExperienceHasMany {
  create: [PersonalExperienceInput!]
}
input CommunityExperienceHasMany {
  create: [CommunityExperienceInput!]
}
input EducationExperienceHasMany {
  create: [EducationExperienceInput!]
}
input AwardExperienceHasMany {
  create: [AwardExperienceInput!]
}
input GenericJobTitleBelongsToMany {
  sync: [ID!]
}

input CreatePoolInput {
  classification: ClassificationBelongsTo
  department: DepartmentBelongsTo!
}

input DuplicatePoolInput {
  departmentId: ID
}

input CreateGeneralQuestionInput {
  question: LocalizedStringInput!
  sortOrder: Int @rename(attribute: "sort_order")
}

input UpdateGeneralQuestionInput {
  id: ID!
  question: LocalizedStringInput
  sortOrder: Int @rename(attribute: "sort_order")
}

input UpdateGeneralQuestionsHasMany {
  create: [CreateGeneralQuestionInput!]
  update: [UpdateGeneralQuestionInput!]
  delete: [ID!]
}

input SyncScreeningQuestionsInput {
  id: ID
  question: LocalizedStringInput!
  sortOrder: Int
}

input UpdatePoolInput {
  # Pool name and classification
  name: LocalizedStringInput
  classification: ClassificationBelongsTo
  department: DepartmentBelongsTo
  stream: PoolStream
  processNumber: String @rename(attribute: "process_number")
  # Closing date
  closingDate: DateTime
    @rename(attribute: "closing_date")
    @rules(
      apply: ["after:today"]
      messages: [{ rule: "after", message: "UpdatePoolClosingDate" }]
    )
  closingReason: String @rename(attribute: "closing_reason")
  # Your impact
  yourImpact: LocalizedStringInput @rename(attribute: "your_impact")
  # Work Tasks
  keyTasks: LocalizedStringInput @rename(attribute: "key_tasks")
  # What to expect
  whatToExpect: LocalizedStringInput @rename(attribute: "what_to_expect")
  # Special note
  specialNote: LocalizedStringInput @rename(attribute: "special_note")
  # What to expect after admission
  whatToExpectAdmission: LocalizedStringInput
    @rename(attribute: "what_to_expect_admission")
  # About us (team, department, etc.)
  aboutUs: LocalizedStringInput @rename(attribute: "about_us")
  # Other requirements
  language: PoolLanguage @rename(attribute: "advertisement_language")
  securityClearance: SecurityStatus @rename(attribute: "security_clearance")
  location: LocalizedStringInput @rename(attribute: "advertisement_location")
  isRemote: Boolean @rename(attribute: "is_remote")
  publishingGroup: PublishingGroup @rename(attribute: "publishing_group")
  opportunityLength: PoolOpportunityLength
    @rename(attribute: "opportunity_length")
  generalQuestions: UpdateGeneralQuestionsHasMany
}

input UpdatePublishedPoolInput @validator {
  changeJustification: String! @rename(attribute: "change_justification")
  yourImpact: LocalizedStringInput @rename(attribute: "your_impact")
  keyTasks: LocalizedStringInput @rename(attribute: "key_tasks")
  whatToExpect: LocalizedStringInput @rename(attribute: "what_to_expect")
  specialNote: LocalizedStringInput @rename(attribute: "special_note")
  whatToExpectAdmission: LocalizedStringInput
    @rename(attribute: "what_to_expect_admission")
  aboutUs: LocalizedStringInput @rename(attribute: "about_us")
}

input CreatePoolSkillInput {
  type: PoolSkillType!
  requiredLevel: SkillLevel @rename(attribute: "required_skill_level")
}

input UpdatePoolSkillInput {
  requiredLevel: SkillLevel @rename(attribute: "required_skill_level")
}

input AssessmentStepInput {
  type: AssessmentStepType
    @rules(
      apply: ["notIn:APPLICATION_SCREENING"]
      messages: [{ rule: "not_in", message: "InvalidAssessmentTypeSelection" }]
    )
  title: LocalizedStringInput
  poolSkills: PoolSkillBelongsToMany
}

input ScreeningQuestionAssessmentStepInput {
  title: LocalizedStringInput
  poolSkills: PoolSkillBelongsToMany
}

input CreateAssessmentResultInput
  @validator(
    class: "App\\GraphQL\\Validators\\CreateAssessmentResultInputValidator"
  ) {
  assessmentStepId: UUID! @rename(attribute: "assessment_step_id")
  poolCandidateId: UUID! @rename(attribute: "pool_candidate_id")
  poolSkillId: UUID @rename(attribute: "pool_skill_id")
  assessmentResultType: AssessmentResultType
    @rename(attribute: "assessment_result_type")
  assessmentDecision: AssessmentDecision
    @rename(attribute: "assessment_decision")
  justifications: [AssessmentResultJustification]
  assessmentDecisionLevel: AssessmentDecisionLevel
    @rename(attribute: "assessment_decision_level")
  skillDecisionNotes: String @rename(attribute: "skill_decision_notes")
}

input UpdateAssessmentResultInput
  @validator(
    class: "App\\GraphQL\\Validators\\UpdateAssessmentResultInputValidator"
  ) {
  id: UUID!
  assessmentResultType: AssessmentResultType
    @rename(attribute: "assessment_result_type")
  assessmentDecision: AssessmentDecision
    @rename(attribute: "assessment_decision")
  justifications: [AssessmentResultJustification]
  assessmentDecisionLevel: AssessmentDecisionLevel
    @rename(attribute: "assessment_decision_level")
  skillDecisionNotes: String @rename(attribute: "skill_decision_notes")
}

input PoolSkillBelongsToMany {
  sync: [UUID!]!
}

input RoleInput {
  roleId: ID!
  teamId: ID
}

input RoleAssignmentHasMany
  @validator(class: "App\\GraphQL\\Validators\\RoleInputValidator") {
  attach: [RoleInput]
  detach: [RoleInput]
}

# This input only accepts Team-Based roles. It is assumed that a team id will be provided at a higher level of input.
input RolesForTeamInput
  @validator(class: "App\\GraphQL\\Validators\\TeamRolesInputValidator") {
  roles: [ID!]
}

input RolesForTeamHasMany {
  attach: RolesForTeamInput
  detach: RolesForTeamInput
  sync: RolesForTeamInput
}

input UpdateUserTeamRolesInput {
  teamId: ID!
  userId: UUID!
  roleAssignments: RolesForTeamHasMany!
}

input GeneralResponseBelongsTo {
  connect: ID!
}

input CreateGeneralQuestionResponseInput {
  generalQuestion: GeneralResponseBelongsTo!
  answer: String!
}

input UpdateGeneralQuestionResponseInput {
  id: ID!
  answer: String
}

input UpdateGeneralQuestionResponsesHasMany {
  create: [CreateGeneralQuestionResponseInput!]
  update: [UpdateGeneralQuestionResponseInput!]
  delete: [ID!]
}

input ScreeningResponseBelongsTo {
  connect: ID!
}

input CreateScreeningQuestionResponseInput {
  screeningQuestion: ScreeningResponseBelongsTo!
  answer: String!
}

input UpdateScreeningQuestionResponseInput {
  id: ID!
  answer: String
}

input UpdateScreeningQuestionResponsesHasMany {
  create: [CreateScreeningQuestionResponseInput!]
  update: [UpdateScreeningQuestionResponseInput!]
  delete: [ID!]
}

input UpdateEducationExperiencesRequirementBelongsToMany {
  sync: [ID!]
}

input UpdateApplicationInput {
  # can only connect a step, not disconnect or sync
  insertSubmittedStep: ApplicationStep
  generalQuestionResponses: UpdateGeneralQuestionResponsesHasMany
  screeningQuestionResponses: UpdateScreeningQuestionResponsesHasMany
  educationRequirementOption: EducationRequirementOption
    @rename(attribute: "education_requirement_option")
  # experiences for meeting minimum criteria
  educationRequirementExperiences: UpdateEducationExperiencesRequirementBelongsToMany

  # Used to validate essential skills
  applicationId: ID
    @rename(attribute: "id")
    @rules(apply: ["App\\Rules\\HasEssentialSkills"])
}

input DateRange {
  from: DateTime!
  to: DateTime! @rules(apply: ["after_or_equal:from"])
}

input NotificationFilterInput {
  onlyUnread: Boolean @scope
  readAt: DateRange @whereBetween(key: "read_at")
  createdAt: DateRange @whereBetween(key: "created_at")
}

type Mutation {
  # User mutations
  createUser(user: CreateUserInput! @spread): User
    @create
    @guard
    @canModel(ability: "create")
    @throttle(maxAttempts: 100)
  updateUserAsUser(id: ID!, user: UpdateUserAsUserInput! @spread): User
    @update
    @guard
    @canFind(ability: "update", find: "id", injectArgs: true)
  updateUserAsAdmin(id: ID!, user: UpdateUserAsAdminInput! @spread): User
    @update
    @guard
    @canFind(ability: "update", find: "id", injectArgs: true)
  updateUserSub(updateUserSubInput: UpdateUserSubInput! @spread): UserAuthInfo
    @update(model: "User")
    @canModel(ability: "updateSub", model: "User")
  updateUserRoles(
    updateUserRolesInput: UpdateUserRolesInput! @spread
  ): UserAuthInfo
    @guard
    @update(model: "User")
    @canModel(ability: "updateRoles", model: "User", injectArgs: true)
  deleteUser(id: ID! @whereKey): User
    @delete
    @guard
    @canFind(ability: "delete", find: "id")
  restoreUser(id: ID! @whereKey): User
    @restore
    @guard
    @canFind(ability: "restore", find: "id")
  sendUserEmailVerification: User @guard
  verifyUserEmail(code: String!): User @guard

  # poolCandidate mutations
  createPoolCandidateAsAdmin(
    poolCandidate: CreatePoolCandidateAsAdminInput! @spread
  ): PoolCandidate
    @create
    @guard
    @canModel(ability: "create")
    @injectNow(name: "submitted_at")
  updatePoolCandidateStatus(
    id: UUID!
    poolCandidate: UpdatePoolCandidateStatusInput! @spread
  ): PoolCandidate
    @update
    @guard
    @canFind(ability: "updateStatus", find: "id", injectArgs: true)
  # Return a boolean to prevent automatically updating the client's cache
  togglePoolCandidateBookmark(id: ID!): Boolean
    @guard
    @canFind(
      ability: "updateBookmark"
      find: "id"
      model: "PoolCandidate"
      injectArgs: true
    )
  updatePoolCandidateClaimVerification(
    id: UUID!
    poolCandidate: UpdatePoolCandidateClaimVerificationInput! @spread
  ): PoolCandidate @update @guard @canFind(ability: "updateNotes", find: "id")
  updatePoolCandidateNotes(id: UUID!, notes: String): PoolCandidate
    @update
    @guard
    @canFind(ability: "updateNotes", find: "id")
  removeCandidate(
    id: UUID!
    removalReason: CandidateRemovalReason!
    removalReasonOther: String
  ): PoolCandidate
    @guard
    @canFind(ability: "updateDecision", find: "id", injectArgs: true)
  reinstateCandidate(id: UUID!): PoolCandidate
    @guard
    @canFind(ability: "updateDecision", find: "id", injectArgs: true)
  deletePoolCandidate(id: ID! @whereKey): PoolCandidate
    @delete
    @guard
    @canFind(ability: "delete", find: "id")
  qualifyCandidate(id: UUID!, expiryDate: Date!): PoolCandidate
    @guard
    @canFind(ability: "updateDecision", find: "id", injectArgs: true)
    @validator(class: "App\\GraphQL\\Validators\\QualifyCandidateValidator")
  disqualifyCandidate(
    id: UUID!
    reason: DisqualificationReason!
  ): PoolCandidate
    @guard
    @canFind(ability: "updateDecision", find: "id", injectArgs: true)
    @validator(class: "App\\GraphQL\\Validators\\DisqualifyCandidateValidator")
  revertFinalDecision(id: UUID!): PoolCandidate
    @guard
    @canFind(ability: "updateDecision", find: "id", injectArgs: true)
    @validator(class: "App\\GraphQL\\Validators\\RevertFinalDecisionValidator")
  placeCandidate(
    id: UUID!
    placeCandidate: PlaceCandidateInput! @spread
  ): PoolCandidate
    @guard
    @canFind(ability: "updatePlacement", find: "id", injectArgs: true)
    @validator(class: "App\\GraphQL\\Validators\\PlaceCandidateValidator")
  revertPlaceCandidate(id: UUID!): PoolCandidate
    @guard
    @canFind(ability: "updatePlacement", find: "id", injectArgs: true)
    @validator(class: "App\\GraphQL\\Validators\\RevertPlaceCandidateValidator")

  createClassification(
    classification: CreateClassificationInput! @spread
  ): Classification @create @guard @canModel(ability: "create")
  updateClassification(
    id: ID!
    classification: UpdateClassificationInput! @spread
  ): Classification @update @guard @canFind(ability: "update", find: "id")
  deleteClassification(id: ID! @whereKey): Classification
    @delete
    @guard
    @canFind(ability: "delete", find: "id")
  createDepartment(department: CreateDepartmentInput! @spread): Department
    @create
    @guard
    @canModel(ability: "create")
  updateDepartment(
    id: ID!
    department: UpdateDepartmentInput! @spread
  ): Department @update @canFind(ability: "update", find: "id") @validator
  deleteDepartment(id: ID! @whereKey): Department
    @delete
    @guard
    @canFind(ability: "delete", find: "id")

  # SearchRequest mutations
  createPoolCandidateSearchRequest(
    poolCandidateSearchRequest: CreatePoolCandidateSearchRequestInput! @spread
  ): PoolCandidateSearchRequest @create @canModel(ability: "create")
  updatePoolCandidateSearchRequest(
    id: ID!
    poolCandidateSearchRequest: UpdatePoolCandidateSearchRequestInput! @spread
  ): PoolCandidateSearchRequest
    @update
    @guard
    @canFind(ability: "update", find: "id")
  deletePoolCandidateSearchRequest(
    id: ID! @whereKey
  ): PoolCandidateSearchRequest
    @delete
    @guard
    @canFind(ability: "delete", find: "id")

  createSkillFamily(skillFamily: CreateSkillFamilyInput! @spread): SkillFamily
    @create
    @guard
    @canModel(ability: "create")
  updateSkillFamily(
    id: ID!
    skillFamily: UpdateSkillFamilyInput! @spread
  ): SkillFamily @update @guard @canFind(ability: "update", find: "id")

  # skill mutations
  createSkill(skill: CreateSkillInput! @spread): Skill
    @create
    @guard
    @canModel(ability: "create")
  updateSkill(id: ID!, skill: UpdateSkillInput! @spread): Skill
    @update
    @guard
    @canFind(ability: "update", find: "id")
  deleteSkill(id: UUID! @whereKey): Skill
    @delete
    @validator(class: "App\\GraphQL\\Validators\\DeleteSkillValidator")
    @canModel(ability: "delete")

  createWorkExperience(
    userId: ID! @rename(attribute: "user_id")
    workExperience: WorkExperienceInput! @spread
  ): WorkExperience @create @canModel(ability: "create", injectArgs: true)
  createPersonalExperience(
    userId: ID! @rename(attribute: "user_id")
    personalExperience: PersonalExperienceInput! @spread
  ): PersonalExperience @create @canModel(ability: "create", injectArgs: true)
  createCommunityExperience(
    userId: ID! @rename(attribute: "user_id")
    communityExperience: CommunityExperienceInput! @spread
  ): CommunityExperience @create @canModel(ability: "create", injectArgs: true)
  createEducationExperience(
    userId: ID! @rename(attribute: "user_id")
    educationExperience: EducationExperienceInput! @spread
  ): EducationExperience @create @canModel(ability: "create", injectArgs: true)
  createAwardExperience(
    userId: ID! @rename(attribute: "user_id")
    awardExperience: AwardExperienceInput! @spread
  ): AwardExperience @create @canModel(ability: "create", injectArgs: true)
  updateWorkExperience(
    id: ID!
    workExperience: WorkExperienceInput! @spread
  ): WorkExperience @update @guard @canFind(ability: "update", find: "id")
  updatePersonalExperience(
    id: ID!
    personalExperience: PersonalExperienceInput! @spread
  ): PersonalExperience @update @guard @canFind(ability: "update", find: "id")
  updateCommunityExperience(
    id: ID!
    communityExperience: CommunityExperienceInput! @spread
  ): CommunityExperience @update @guard @canFind(ability: "update", find: "id")
  updateEducationExperience(
    id: ID!
    educationExperience: EducationExperienceInput! @spread
  ): EducationExperience @update @guard @canFind(ability: "update", find: "id")
  updateAwardExperience(
    id: ID!
    awardExperience: AwardExperienceInput! @spread
  ): AwardExperience @update @guard @canFind(ability: "update", find: "id")
  deleteWorkExperience(id: ID! @whereKey): WorkExperience
    @delete
    @guard
    @canFind(ability: "delete", find: "id")
  deletePersonalExperience(id: ID! @whereKey): PersonalExperience
    @delete
    @guard
    @canFind(ability: "delete", find: "id")
  deleteCommunityExperience(id: ID! @whereKey): CommunityExperience
    @delete
    @guard
    @canFind(ability: "delete", find: "id")
  deleteEducationExperience(id: ID! @whereKey): EducationExperience
    @delete
    @guard
    @canFind(ability: "delete", find: "id")
  deleteAwardExperience(id: ID! @whereKey): AwardExperience
    @delete
    @guard
    @canFind(ability: "delete", find: "id")

  # Pool mutations
  createPool(
    userId: ID! @rename(attribute: "user_id")
    teamId: ID! @rename(attribute: "team_id")
    communityId: ID! @rename(attribute: "community_id")
    pool: CreatePoolInput! @spread
  ): Pool @create @guard @canModel(ability: "create", injectArgs: true)
  duplicatePool(
    id: ID!
    teamId: ID! @rename(attribute: "team_id")
    pool: DuplicatePoolInput! @spread
  ): Pool @guard @canModel(ability: "duplicate", injectArgs: true)
  updatePool(id: ID!, pool: UpdatePoolInput! @spread): Pool
    @update
    @guard
    @canFind(ability: "updateDraft", find: "id")
  updatePublishedPool(id: ID!, pool: UpdatePublishedPoolInput! @spread): Pool
    @update
    @guard
    @canFind(ability: "updatePublished", find: "id")
  togglePoolUserBookmark(poolId: UUID! @rename(attribute: "pool_id")): Pool
    @guard
    @canFind(ability: "view", find: "pool_id", model: "Pool", injectArgs: true)

  createPoolSkill(
    poolId: ID! @rename(attribute: "pool_id")
    skillId: ID! @rename(attribute: "skill_id")
    poolSkill: CreatePoolSkillInput! @spread
  ): PoolSkill
    @create
    @guard
    @canFind(
      ability: "updateDraft"
      find: "pool_id"
      model: "Pool"
      injectArgs: true
    )
  updatePoolSkill(id: ID!, poolSkill: UpdatePoolSkillInput! @spread): PoolSkill
    @update
    @guard
    @canFind(ability: "update", find: "id", model: "PoolSkill")
  deletePoolSkill(id: ID! @whereKey): PoolSkill
    @delete
    @guard
    @canFind(ability: "delete", find: "id", model: "PoolSkill")
  publishPool(id: ID!): Pool @guard @canFind(ability: "publish", find: "id")
  changePoolClosingDate(id: ID!, closingDate: DateTime!): Pool
    @guard
    @canFind(ability: "changePoolClosingDate", find: "id")
    @validator(
      class: "App\\GraphQL\\Validators\\ChangePoolClosingDateValidator"
    )
  closePool(
    id: ID!
    reason: String!
      @rename(attribute: "closing_reason")
      @rules(apply: ["required"])
  ): Pool @guard @canFind(ability: "closePool", find: "id")
  deletePool(id: ID! @whereKey): Pool
    @forceDelete(model: "Pool")
    @guard
    @canFind(ability: "deleteDraft", find: "id")
  archivePool(id: ID!): Pool
    @guard
    @canFind(ability: "archiveAndUnarchive", find: "id")
  unarchivePool(id: ID!): Pool
    @guard
    @canFind(ability: "archiveAndUnarchive", find: "id")

  # Application mutations
  changeApplicationSuspendedAt(id: ID!, isSuspended: Boolean!): PoolCandidate
    @guard
    @canFind(ability: "suspend", find: "id")
  createApplication(userId: ID!, poolId: ID!): PoolCandidate
    @canModel(ability: "createDraft")
  deleteApplication(id: ID!): PoolCandidate
    @guard
    @canFind(ability: "delete", find: "id", model: "PoolCandidate")
  submitApplication(id: ID!, signature: String!): PoolCandidate
    @guard
    @canFind(ability: "submit", find: "id")
  updateApplication(
    id: ID!
    application: UpdateApplicationInput! @spread
  ): PoolCandidate
    @update(model: "PoolCandidate")
    @guard
    @canFind(ability: "update", find: "id", model: "PoolCandidate")

  # Teams mutations
  createTeam(team: CreateTeamInput! @spread): Team
    @create
    @canModel(ability: "create")
  updateTeam(id: UUID!, team: UpdateTeamInput! @spread): Team
    @update
    @canModel(ability: "update")
    @validator
  deleteTeam(id: UUID! @whereKey): Team
    @delete
    @guard
    @canFind(ability: "delete", find: "id")
  updateUserTeamRoles(
    teamRoleAssignments: UpdateUserTeamRolesInput! @spread
  ): Team
    @guard
    @canFind(ability: "assignTeamMembers", find: "teamId")
    @deprecated(reason: "use updateUserRoles")

  # Communities mutations
  createCommunity(community: CreateCommunityInput! @spread): Community
    @create
    @canModel(ability: "create")
    @validator
  updateCommunity(
    id: UUID!
    community: UpdateCommunityInput! @spread
  ): Community @update @canFind(ability: "update", find: "id") @validator

  # Notifications
  markNotificationAsRead(id: UUID!): Notification @guard # can only affect notifications belonging to the logged-in user
  markNotificationAsUnread(id: UUID!): Notification @guard
  deleteNotification(id: UUID!): Notification @guard
  markAllNotificationsAsRead: [Notification] @guard
  updateEnabledNotifications(
    enabledEmailNotifications: [NotificationFamily]
    enabledInAppNotifications: [NotificationFamily]
  ): User @guard @validator
  # UserSkill mutations
  createUserSkill(
    userId: UUID! @rename(attribute: "user_id")
    skillId: UUID! @rename(attribute: "skill_id")
    userSkill: CreateUserSkillInput @spread
  ): UserSkill @canModel(ability: "create", injectArgs: true)
  updateUserSkill(
    id: UUID!
    userSkill: UpdateUserSkillInput @spread
  ): UserSkill @update @canFind(ability: "update", find: "id")
  updateUserSkillRankings(
    userId: UUID!
    userSkillRanking: UpdateUserSkillRankingsInput!
  ): User @canFind(ability: "update", find: "userId")
  deleteUserSkill(id: UUID! @whereKey): UserSkill
    @canFind(ability: "delete", find: "id")
    @delete

  # Assessment mutations
  createAssessmentStep(
    poolId: UUID! @rename(attribute: "pool_id")
    assessmentStep: AssessmentStepInput @spread
  ): AssessmentStep
    @create
    @guard
    @canModel(ability: "create", injectArgs: true)
  updateAssessmentStep(
    id: UUID!
    assessmentStep: AssessmentStepInput @spread
  ): AssessmentStep @update @guard @canFind(ability: "update", find: "id")
  swapAssessmentStepOrder(stepIdA: UUID!, stepIdB: UUID!): [AssessmentStep]
    @guard
    @canFind(ability: "update", find: "stepIdA")
    @canFind(ability: "update", find: "stepIdB")
  createOrUpdateScreeningQuestionAssessmentStep(
    poolId: UUID!
    screeningQuestions: [SyncScreeningQuestionsInput]
    assessmentStep: ScreeningQuestionAssessmentStepInput
  ): Pool @guard @canFind(ability: "updateDraft", find: "poolId")
  deleteAssessmentStep(id: UUID! @whereKey): AssessmentStep
    @delete
    @guard
    @canFind(ability: "update", find: "id")
  createAssessmentResult(
    createAssessmentResult: CreateAssessmentResultInput! @spread
  ): AssessmentResult
    @create
    @guard
    @canModel(ability: "create", injectArgs: true)
  updateAssessmentResult(
    updateAssessmentResult: UpdateAssessmentResultInput! @spread
  ): AssessmentResult @update @guard @canFind(ability: "update", find: "id")
  deleteAssessmentResult(id: UUID! @whereKey): AssessmentResult
    @delete
    @canFind(ability: "update", find: "id")

  updateSitewideAnnouncement(
    sitewideAnnouncementInput: SitewideAnnouncementInput! @spread
  ): SitewideAnnouncement @guard

  # File downloads
  downloadPoolCandidatesCsv(
    ids: [UUID!],
    where: PoolCandidateSearchInput,
    locale: Language
  ): Boolean! @guard
  downloadPoolCandidatesDoc(
    ids: [UUID!]!
    anonymous: Boolean!
    locale: Language
  ): Boolean! @guard
  downloadUsersCsv(
    ids: [UUID!],
    where: UserFilterInput
    locale: Language
  ): Boolean! @guard
  downloadApplicationsDoc(ids: [UUID!]!, locale: Language): Boolean! @guard
  downloadUsersDoc(
    ids: [UUID!]!
    anonymous: Boolean!
    locale: Language
  ): Boolean! @guard
}

#import directiveForms.graphql
