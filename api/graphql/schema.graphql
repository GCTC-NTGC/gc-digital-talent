"A date string with format `Y-m-d`, e.g. `2011-05-23`."
scalar Date @scalar(class: "Nuwave\\Lighthouse\\Schema\\Types\\Scalars\\Date")

"A datetime string with format `Y-m-d H:i:s`, e.g. `2018-05-23 13:43:32`."
scalar DateTime
  @scalar(class: "Nuwave\\Lighthouse\\Schema\\Types\\Scalars\\DateTime")

"A RFC 5321 compliant email."
scalar Email @scalar(class: "MLL\\GraphQLScalars\\Email")

"A phone number string, accepts any string"
scalar PhoneNumber

"A human readable ID"
scalar KeyString

"Arbitrary data encoded in JavaScript Object Notation. See https://www.json.org."
scalar JSON @scalar(class: "MLL\\GraphQLScalars\\JSON")

"128 bit universally unique identifier (UUID)"
scalar UUID @scalar(class: "UUID")

type LocalizedString {
  en: String
  fr: String
  localized: String
}

type LocalizedEnumString {
  value: String!
  label: LocalizedString!
}

type UserAuthInfo {
  id: UUID!
  sub: String
  roleAssignments: [RoleAssignment] @hasMany
  createdDate: DateTime @rename(attribute: "created_at")
  deletedDate: DateTime @rename(attribute: "deleted_at")
}

type User {
  id: ID!
  createdDate: DateTime @rename(attribute: "created_at")
  updatedDate: DateTime @rename(attribute: "updated_at")
  deletedDate: DateTime @rename(attribute: "deleted_at")

  # Personal info
  firstName: String @rename(attribute: "first_name")
  lastName: String @rename(attribute: "last_name")
  email: Email
  isEmailVerified: Boolean
  telephone: PhoneNumber
  preferredLang: LocalizedLanguage @rename(attribute: "preferred_lang")
  preferredLanguageForInterview: LocalizedLanguage
    @rename(attribute: "preferred_language_for_interview")
  preferredLanguageForExam: LocalizedLanguage
    @rename(attribute: "preferred_language_for_exam")
  currentProvince: LocalizedProvinceOrTerritory
    @rename(attribute: "current_province")
  currentCity: String @rename(attribute: "current_city")
  citizenship: LocalizedCitizenshipStatus
  armedForcesStatus: LocalizedArmedForcesStatus
    @rename(attribute: "armed_forces_status")

  # Language
  lookingForEnglish: Boolean @rename(attribute: "looking_for_english")
  lookingForFrench: Boolean @rename(attribute: "looking_for_french")
  lookingForBilingual: Boolean @rename(attribute: "looking_for_bilingual")
  firstOfficialLanguage: LocalizedLanguage
    @rename(attribute: "first_official_language")
  secondLanguageExamCompleted: Boolean
    @rename(attribute: "second_language_exam_completed")
  secondLanguageExamValidity: Boolean
    @rename(attribute: "second_language_exam_validity")
  comprehensionLevel: LocalizedEvaluatedLanguageAbility
    @rename(attribute: "comprehension_level")
  writtenLevel: LocalizedEvaluatedLanguageAbility
    @rename(attribute: "written_level")
  verbalLevel: LocalizedEvaluatedLanguageAbility
    @rename(attribute: "verbal_level")
  estimatedLanguageAbility: LocalizedEstimatedLanguageAbility
    @rename(attribute: "estimated_language_ability")

  # Gov info
  isGovEmployee: Boolean @rename(attribute: "computed_is_gov_employee")
  isVerifiedGovEmployee: Boolean
  workEmail: Email @rename(attribute: "work_email")
  isWorkEmailVerified: Boolean
  govEmployeeType: LocalizedGovEmployeeType
    @rename(attribute: "computed_gov_employee_type")
  govRole: String @rename(attribute: "computed_gov_role")
  govPositionType: LocalizedGovPositionType
    @rename(attribute: "computed_gov_position_type")
  govEndDate: Date @rename(attribute: "computed_gov_end_date")
  currentClassification: Classification @belongsTo # Users current classification
  department: Department @belongsTo
  hasPriorityEntitlement: Boolean @rename(attribute: "has_priority_entitlement")
  priorityNumber: String @rename(attribute: "priority_number")

  # Employment equity
  isWoman: Boolean @rename(attribute: "is_woman")
  hasDisability: Boolean @rename(attribute: "has_disability")
  isVisibleMinority: Boolean @rename(attribute: "is_visible_minority")
  indigenousCommunities: [LocalizedIndigenousCommunity]
    @rename(attribute: "indigenous_communities")
  indigenousDeclarationSignature: String
    @rename(attribute: "indigenous_declaration_signature")

  # Applicant info
  hasDiploma: Boolean @rename(attribute: "has_diploma")
  locationPreferences: [LocalizedWorkRegion]
    @rename(attribute: "location_preferences")
  locationExemptions: String @rename(attribute: "location_exemptions")
  acceptedOperationalRequirements: [LocalizedOperationalRequirement]
    @rename(attribute: "accepted_operational_requirements")
  positionDuration: [PositionDuration] @rename(attribute: "position_duration")

  # Employee profile info
  employeeProfile: EmployeeProfile @hasOne @canFind(ability: "view")

  # Pool info
  poolCandidates: [PoolCandidate]
    @hasMany(scopes: ["authorizedToView"])
    @canResolved(ability: "view") # PoolCandidate objects associate the user with a pool
  # Experiences
  experiences: [Experience] @belongsToMany # All experiences that a user owns
  awardExperiences: [AwardExperience] @belongsToMany # Award experiences that a user owns
  communityExperiences: [CommunityExperience] @belongsToMany # Community experiences that a user owns
  educationExperiences: [EducationExperience] @belongsToMany # Education experiences that a user owns
  personalExperiences: [PersonalExperience] @belongsToMany # Personal experiences that a user owns
  workExperiences: [WorkExperience] @belongsToMany # Work experiences that a user owns
  # Skill Library
  userSkills(includeSkillIds: [UUID] @in(key: "skill_id")): [UserSkill] @hasMany
  topTechnicalSkillsRanking: [UserSkill] @with(relation: "userSkills")
  topBehaviouralSkillsRanking: [UserSkill] @with(relation: "userSkills")
  improveTechnicalSkillsRanking: [UserSkill] @with(relation: "userSkills")
  improveBehaviouralSkillsRanking: [UserSkill] @with(relation: "userSkills")
  # Profile Status
  isProfileComplete: Boolean
  priorityWeight: Int @rename(attribute: "priority_weight")
  priority: LocalizedPriorityWeight
  # authorization and roles
  authInfo: UserAuthInfo @self
  # site options
  enabledEmailNotifications: [NotificationFamily]
    @rename(attribute: "enabled_email_notifications")
  enabledInAppNotifications: [NotificationFamily]
    @rename(attribute: "enabled_in_app_notifications")

  # Bookmarks
  poolBookmarks: [Pool] @belongsToMany
  poolCandidateSearchRequests: [PoolCandidateSearchRequest!]
    @canResolved(ability: "view") # Search requests submitted by a user
  # Nominations
  talentNominationsAsSubmitter: [TalentNomination!]
    @hasMany
    @canResolved(ability: "view") # Search talent requests submitted by a user
}

type CommunityInterest {
  id: UUID!
  community: Community! @belongsTo
  user: User! @belongsTo @canRoot(ability: "viewUser")
  workStreams: [WorkStream!] @belongsToMany
  jobInterest: Boolean @rename(attribute: "job_interest")
  trainingInterest: Boolean @rename(attribute: "training_interest")
  additionalInformation: String @rename(attribute: "additional_information")
  interestInDevelopmentPrograms: [DevelopmentProgramInterest!] @hasMany
}

# A pivot table for employees to express interest in the development programs of a community.
type DevelopmentProgramInterest {
  id: UUID!
  developmentProgram: DevelopmentProgram! @belongsTo
  participationStatus: DevelopmentProgramParticipationStatus
    @rename(attribute: "participation_status")
  completionDate: Date @rename(attribute: "completion_date")
}

type EmployeeProfile {
  lateralMoveInterest: Boolean
    @rename(attribute: "career_planning_lateral_move_interest")
  lateralMoveTimeFrame: LocalizedTimeFrame
    @rename(attribute: "career_planning_lateral_move_time_frame")
  lateralMoveOrganizationType: [LocalizedOrganizationTypeInterest!]
    @rename(attribute: "career_planning_lateral_move_organization_type")

  promotionMoveInterest: Boolean
    @rename(attribute: "career_planning_promotion_move_interest")
  promotionMoveTimeFrame: LocalizedTimeFrame
    @rename(attribute: "career_planning_promotion_move_time_frame")
  promotionMoveOrganizationType: [LocalizedOrganizationTypeInterest!]
    @rename(attribute: "career_planning_promotion_move_organization_type")

  mentorshipStatus: [LocalizedMentorship!]
    @rename(attribute: "career_planning_mentorship_status")
  mentorshipInterest: [LocalizedMentorship!]
    @rename(attribute: "career_planning_mentorship_interest")
  execInterest: Boolean @rename(attribute: "career_planning_exec_interest")
  execCoachingStatus: [LocalizedExecCoaching!]
    @rename(attribute: "career_planning_exec_coaching_status")
  execCoachingInterest: [LocalizedExecCoaching!]
    @rename(attribute: "career_planning_exec_coaching_interest")
  aboutYou: String @rename(attribute: "career_planning_about_you")
  learningGoals: String @rename(attribute: "career_planning_learning_goals")
  workStyle: String @rename(attribute: "career_planning_work_style")
  nextRoleJobTitle: String @rename(attribute: "next_role_job_title")
  careerObjectiveJobTitle: String
    @rename(attribute: "career_objective_job_title")
  nextRoleAdditionalInformation: String
    @rename(attribute: "next_role_additional_information")
  careerObjectiveAdditionalInformation: String
    @rename(attribute: "career_objective_additional_information")
  nextRoleCommunity: Community @belongsTo
  careerObjectiveCommunity: Community @belongsTo
  nextRoleCommunityOther: String @rename(attribute: "next_role_community_other")
  careerObjectiveCommunityOther: String
    @rename(attribute: "career_objective_community_other")
  nextRoleClassification: Classification @belongsTo
  careerObjectiveClassification: Classification @belongsTo
  nextRoleWorkStreams: [WorkStream!] @belongsToMany
  careerObjectiveWorkStreams: [WorkStream!] @belongsToMany
  nextRoleDepartments: [Department!] @belongsToMany
  careerObjectiveDepartments: [Department!] @belongsToMany
  nextRoleTargetRole: LocalizedTargetRole
    @rename(attribute: "next_role_target_role")
  careerObjectiveTargetRole: LocalizedTargetRole
    @rename(attribute: "career_objective_target_role")
  nextRoleTargetRoleOther: String
    @rename(attribute: "next_role_target_role_other")
  careerObjectiveTargetRoleOther: String
    @rename(attribute: "career_objective_target_role_other")

  nextRoleIsCSuiteRole: Boolean @rename(attribute: "next_role_is_c_suite_role")
  careerObjectiveIsCSuiteRole: Boolean
    @rename(attribute: "career_objective_is_c_suite_role")
  nextRoleCSuiteRoleTitle: LocalizedCSuiteRoleTitle
    @rename(attribute: "next_role_c_suite_role_title")
  careerObjectiveCSuiteRoleTitle: LocalizedCSuiteRoleTitle
    @rename(attribute: "career_objective_c_suite_role_title")

  communityInterests(id: UUID @eq): [CommunityInterest!] @belongsToMany

  userPublicProfile: UserPublicProfile
}

interface Notification {
  id: ID!
  readAt: DateTime @rename(attribute: "read_at")
  createdAt: DateTime! @rename(attribute: "created_at")
  updatedAt: DateTime! @rename(attribute: "updated_at")
}

type TestNotification implements Notification {
  id: ID!
  readAt: DateTime @rename(attribute: "read_at")
  createdAt: DateTime! @rename(attribute: "created_at")
  updatedAt: DateTime! @rename(attribute: "updated_at")

  name: String
}

type ApplicationDeadlineApproachingNotification implements Notification {
  id: ID!
  readAt: DateTime @rename(attribute: "read_at")
  createdAt: DateTime! @rename(attribute: "created_at")
  updatedAt: DateTime! @rename(attribute: "updated_at")

  closingDate: Date
  poolName: LocalizedString
  poolId: ID
  poolCandidateId: ID
}

type NewJobPostedNotification implements Notification {
  id: ID!
  readAt: DateTime @rename(attribute: "read_at")
  createdAt: DateTime! @rename(attribute: "created_at")
  updatedAt: DateTime! @rename(attribute: "updated_at")

  poolId: ID
}

type ApplicationStatusChangedNotification implements Notification {
  id: ID!
  readAt: DateTime @rename(attribute: "read_at")
  createdAt: DateTime! @rename(attribute: "created_at")
  updatedAt: DateTime! @rename(attribute: "updated_at")

  poolName: LocalizedString
}

type SystemNotification implements Notification {
  id: ID!
  readAt: DateTime @rename(attribute: "read_at")
  createdAt: DateTime! @rename(attribute: "created_at")
  updatedAt: DateTime! @rename(attribute: "updated_at")

  message: LocalizedString
  href: LocalizedString
}

type UserFileGeneratedNotification implements Notification {
  id: ID!
  readAt: DateTime @rename(attribute: "read_at")
  createdAt: DateTime! @rename(attribute: "created_at")
  updatedAt: DateTime! @rename(attribute: "updated_at")

  fileName: String
}

type UserFileGenerationErrorNotification implements Notification {
  id: ID!
  readAt: DateTime @rename(attribute: "read_at")
  createdAt: DateTime! @rename(attribute: "created_at")
  updatedAt: DateTime! @rename(attribute: "updated_at")

  fileName: String
}

type UserPublicProfile @model(class: "\\App\\Models\\User") {
  id: ID!
  email: Email
  firstName: String @rename(attribute: "first_name")
  lastName: String @rename(attribute: "last_name")
}

type BasicGovEmployeeProfile @model(class: "\\App\\Models\\User") {
  id: ID!
  workEmail: Email @rename(attribute: "work_email")
  firstName: String @rename(attribute: "first_name")
  lastName: String @rename(attribute: "last_name")
  role: String @rename(attribute: "computed_gov_role")
  department: Department @belongsTo
}

type GeneralQuestion {
  id: ID!
  pool: Pool @belongsTo
  question: LocalizedString
  sortOrder: Int @rename(attribute: "sort_order")
}

type ScreeningQuestion {
  id: ID!
  assessmentStep: AssessmentStep @belongsTo @canResolved(ability: "view")
  question: LocalizedString
  sortOrder: Int @rename(attribute: "sort_order")
}

interface HasRoleAssignments {
  id: ID!
  roleAssignments: [RoleAssignment!]
  teamIdForRoleAssignment: ID # Used to assign roles associated with this resource using the updateUserRoles mutation.
}

type Pool implements HasRoleAssignments {
  id: ID!
  owner: UserPublicProfile @belongsTo(relation: "user")
  team: Team @belongsTo(relation: "legacyTeam") @canModel(ability: "viewAny")
  community: Community @belongsTo(relation: "community")
  name: LocalizedString
  classification: Classification @belongsTo
  operationalRequirements: [LocalizedOperationalRequirement]
    @rename(attribute: "operational_requirements")
  poolCandidates: [PoolCandidate]
    @hasMany(relation: "publishedPoolCandidates", scopes: ["authorizedToView"])
    @canResolved(ability: "view")
    @guard
  poolCandidatesCount: Int
    @count(relation: "poolCandidates", scopes: ["notDraft"])
  keyTasks: LocalizedString @rename(attribute: "key_tasks")
  yourImpact: LocalizedString @rename(attribute: "your_impact")
  whatToExpect: LocalizedString @rename(attribute: "what_to_expect")
  specialNote: LocalizedString @rename(attribute: "special_note")
  whatToExpectAdmission: LocalizedString
    @rename(attribute: "what_to_expect_admission")
  aboutUs: LocalizedString @rename(attribute: "about_us")
  isRemote: Boolean @rename(attribute: "is_remote")
  location: LocalizedString @rename(attribute: "advertisement_location")
  securityClearance: LocalizedSecurityStatus
    @rename(attribute: "security_clearance")
  language: LocalizedPoolLanguage @rename(attribute: "advertisement_language")
  status: LocalizedPoolStatus @rename(attribute: "status")
  workStream: WorkStream @belongsTo
  processNumber: String @rename(attribute: "process_number")
  publishingGroup: LocalizedPublishingGroup
    @rename(attribute: "publishing_group")
  opportunityLength: LocalizedPoolOpportunityLength
    @rename(attribute: "opportunity_length")
  createdDate: DateTime @rename(attribute: "created_at")
  updatedDate: DateTime @rename(attribute: "updated_at")
  generalQuestions: [GeneralQuestion]
    @hasMany
    @orderBy(column: "sort_order", direction: ASC)
  screeningQuestions: [ScreeningQuestion]
    @hasMany
    @orderBy(column: "sort_order", direction: ASC)
  closingDate: DateTime @rename(attribute: "closing_date")
  closingReason: String @rename(attribute: "closing_reason")
  publishedAt: DateTime @rename(attribute: "published_at")
  archivedAt: DateTime @rename(attribute: "archived_at")
  isComplete: Boolean
  assessmentPlanIsComplete: Boolean
  assessmentSteps: [AssessmentStep]
    @hasMany
    @canRoot(ability: "viewAssessmentPlan")
  poolSkills(type: PoolSkillType @where): [PoolSkill] @hasMany
  roleAssignments: [RoleAssignment!]
    @hasManyThrough
    @canRoot(ability: "viewTeamMembers")
  teamIdForRoleAssignment: ID @with(relation: "team")
  department: Department @belongsTo @canQuery(ability: "view")
  areaOfSelection: LocalizedPoolAreaOfSelection
    @rename(attribute: "area_of_selection")
  selectionLimitations: [LocalizedPoolSelectionLimitation!]
    @rename(attribute: "selection_limitations")
}

type GeneralQuestionResponse {
  id: ID!
  answer: String
  generalQuestion: GeneralQuestion @belongsTo
  poolCandidate: PoolCandidate @belongsTo @canResolved(ability: "view")
}

type ScreeningQuestionResponse {
  id: ID!
  answer: String
  screeningQuestion: ScreeningQuestion @belongsTo
}

type AssessmentStep {
  id: ID!
  pool: Pool @belongsTo
  type: LocalizedAssessmentStepType
  sortOrder: Int @rename(attribute: "sort_order")
  title: LocalizedString
  poolSkills: [PoolSkill] @belongsToMany
  assessmentResults: [AssessmentResult]
    @hasMany
    @canRoot(ability: "viewAssessmentResults")
  screeningQuestions: [ScreeningQuestion] @with(relation: "screeningQuestions")
}

type AssessmentResult {
  id: ID!
  assessmentStep: AssessmentStep @belongsTo
  poolCandidate: PoolCandidate @belongsTo
  poolSkill: PoolSkill @belongsTo
  assessmentResultType: AssessmentResultType
    @rename(attribute: "assessment_result_type")
  assessmentDecision: LocalizedAssessmentDecision
    @rename(attribute: "assessment_decision")
  justifications: [LocalizedAssessmentResultJustification]
  assessmentDecisionLevel: LocalizedAssessmentDecisionLevel
    @rename(attribute: "assessment_decision_level")
  skillDecisionNotes: String @rename(attribute: "skill_decision_notes")
}

type AssessmentStepDecision {
  step: UUID!
  decision: AssessmentDecision
}

type AssessmentResultStatus {
  assessmentStepStatuses: [AssessmentStepDecision]
  overallAssessmentStatus: OverallAssessmentStatus
  currentStep: Int # Starts at 1, null indicates all steps successful
}

type PoolSkill {
  id: ID!
  type: LocalizedPoolSkillType
  requiredLevel: SkillLevel @rename(attribute: "required_skill_level")
  skill: Skill @belongsTo
  assessmentSteps: [AssessmentStep]
    @belongsToMany
    @canRoot(ability: "viewAssessmentSteps")
}

type PoolCandidateCategory {
  weight: Int!
  value: PriorityWeight!
  label: LocalizedString!
}

type PoolCandidate {
  id: ID!
  pool: Pool! @belongsTo @canResolved(ability: "view")
  user: User! @belongsTo(relation: "user") @canResolved(ability: "view")
  # Expiry date for this candidate being in the pool.
  expiryDate: Date @rename(attribute: "expiry_date")

  category: PoolCandidateCategory @with(relation: "user")
  status: LocalizedPoolCandidateStatus
    @rename(attribute: "pool_candidate_status")
    @canRoot(ability: "viewStatus")
  statusWeight: Int
    @rename(attribute: "status_weight")
    @canRoot(ability: "viewStatus")
  notes: String @canRoot(ability: "viewNotes")
  archivedAt: DateTime @rename(attribute: "archived_at")
  submittedAt: DateTime @rename(attribute: "submitted_at")
  suspendedAt: DateTime @rename(attribute: "suspended_at")
  deletedDate: DateTime @rename(attribute: "deleted_at")
  isBookmarked: Boolean
    @rename(attribute: "is_bookmarked")
    @canRoot(ability: "viewNotes")
  removedAt: DateTime
    @rename(attribute: "removed_at")
    @canRoot(ability: "viewStatus")
  removalReason: LocalizedCandidateRemovalReason
    @rename(attribute: "removal_reason")
    @canRoot(ability: "viewStatus")
  removalReasonOther: String
    @rename(attribute: "removal_reason_other")
    @canRoot(ability: "viewStatus")

  profileSnapshot: JSON @rename(attribute: "profile_snapshot")
  signature: String
  submittedSteps: [ApplicationStep!] @rename(attribute: "submitted_steps")
  generalQuestionResponses: [GeneralQuestionResponse] @hasMany
  screeningQuestionResponses: [ScreeningQuestionResponse] @hasMany
  educationRequirementOption: LocalizedEducationRequirementOption
    @rename(attribute: "education_requirement_option") # associated experiences to fulfill this called educationRequirementExperiences
  educationRequirementExperiences: [Experience] @belongsToMany
  # record of decision
  assessmentResults: [AssessmentResult]
    @hasMany
    @canRoot(ability: "viewAssessment")
  assessmentStatus: AssessmentResultStatus
    @rename(attribute: "computed_assessment_status")
  finalDecision: LocalizedFinalDecision
    @rename(attribute: "computed_final_decision")
  finalDecisionAt: DateTime
    @rename(attribute: "final_decision_at")
    @canRoot(ability: "viewStatus")
  placedAt: DateTime
    @rename(attribute: "placed_at")
    @canRoot(ability: "viewStatus")
  placedDepartment: Department @belongsTo @canRoot(ability: "viewStatus")

  # claim verification
  veteranVerification: ClaimVerificationResult
    @rename(attribute: "veteran_verification")
    @canRoot(ability: "viewNotes")
  veteranVerificationExpiry: Date
    @rename(attribute: "veteran_verification_expiry")
    @canRoot(ability: "viewNotes")
  priorityVerification: ClaimVerificationResult
    @rename(attribute: "priority_verification")
    @canRoot(ability: "viewNotes")
  priorityVerificationExpiry: Date
    @rename(attribute: "priority_verification_expiry")
    @canRoot(ability: "viewNotes")
}

type PoolCandidateWithSkillCount {
  id: ID!
  poolCandidate: PoolCandidate! @self
  skillCount: Int @rename(attribute: "skill_count") # will always be null unless used with skillsAdditive or skillsIntersectional scope
}

type Classification {
  id: ID!
  name: LocalizedString
  group: String!
  level: Int!
  minSalary: Int @rename(attribute: "min_salary")
  maxSalary: Int @rename(attribute: "max_salary")
  genericJobTitles: [GenericJobTitle] @belongsToMany
}

type GenericJobTitle {
  id: ID!
  key: GenericJobTitleKey!
  name: LocalizedString
  classification: Classification @belongsTo
}

type Department {
  id: ID!
  departmentNumber: Int! @rename(attribute: "department_number")
  name: LocalizedString!
  teams: [Team] @belongsToMany @canModel(ability: "viewAny")
  pools: [Pool]
    @hasMany(scopes: ["authorizedToView"])
    @canResolved(ability: "view")
}

type WorkStream {
  id: UUID!
  key: String
  name: LocalizedString
  plainLanguageName: LocalizedString @rename(attribute: "plain_language_name")
  community: Community @belongsTo
}

type Community implements HasRoleAssignments {
  id: ID!
  key: String!
  name: LocalizedString
  description: LocalizedString
  mandateAuthority: LocalizedString @rename(attribute: "mandate_authority")
  roleAssignments: [RoleAssignment!]
    @hasManyThrough
    @canRoot(ability: "viewTeamMembers")
  teamIdForRoleAssignment: ID @with(relation: "team")
  pools: [Pool]
    @hasMany(scopes: ["authorizedToView"])
    @canResolved(ability: "view")
  workStreams: [WorkStream!] @hasMany
  developmentPrograms: [DevelopmentProgram!] @hasMany
}

type DevelopmentProgram {
  id: UUID!
  name: LocalizedString
  descriptionForProfile: LocalizedString
    @rename(attribute: "description_for_profile")
  descriptionForNominations: LocalizedString
    @rename(attribute: "description_for_nominations")
  community: Community @belongsTo
  eligibleClassifications: [Classification!] @belongsToMany
}

type TalentNominationEvent {
  id: UUID!
  name: LocalizedString!
  description: LocalizedString
  openDate: DateTime! @rename(attribute: "open_date")
  closeDate: DateTime! @rename(attribute: "close_date")
  learnMoreUrl: LocalizedString @rename(attribute: "learn_more_url")
  includeLeadershipCompetencies: Boolean!
    @rename(attribute: "include_leadership_competencies")
  community: Community! @belongsTo
  developmentPrograms: [DevelopmentProgram!] @belongsToMany
}

type TalentNomination {
  id: UUID!
  submittedSteps: [TalentNominationStep!] @rename(attribute: "submitted_steps")
  talentNominationEvent: TalentNominationEvent! @belongsTo
  submittedAt: DateTime @rename(attribute: "submitted_at")
  submitter: BasicGovEmployeeProfile!
    @belongsTo
    @canQuery(ability: "viewAnyBasicGovEmployeeProfile", model: "User")
  submitterRelationshipToNominator: LocalizedTalentNominationSubmitterRelationshipToNominator
    @rename(attribute: "submitter_relationship_to_nominator")
  submitterRelationshipToNominatorOther: String
    @rename(attribute: "submitter_relationship_to_nominator_other")
  nominator: BasicGovEmployeeProfile
    @belongsTo
    @canQuery(ability: "viewAnyBasicGovEmployeeProfile", model: "User")
  nominatorFallbackWorkEmail: String
    @rename(attribute: "nominator_fallback_work_email")
  nominatorFallbackName: String @rename(attribute: "nominator_fallback_name")
  nominatorFallbackClassification: Classification @belongsTo
  nominatorFallbackDepartment: Department @belongsTo
  nominatorReview: LocalizedTalentNominationUserReview
    @rename(attribute: "nominator_review")
  nominee: BasicGovEmployeeProfile
    @belongsTo
    @canQuery(ability: "viewAnyBasicGovEmployeeProfile", model: "User")
  nomineeReview: LocalizedTalentNominationUserReview
    @rename(attribute: "nominee_review")
  nomineeRelationshipToNominator: LocalizedTalentNominationNomineeRelationshipToNominator
    @rename(attribute: "nominee_relationship_to_nominator")
  nomineeRelationshipToNominatorOther: String
    @rename(attribute: "nominee_relationship_to_nominator_other")

  nominateForAdvancement: Boolean @rename(attribute: "nominate_for_advancement")
  nominateForLateralMovement: Boolean
    @rename(attribute: "nominate_for_lateral_movement")
  nominateForDevelopmentPrograms: Boolean
    @rename(attribute: "nominate_for_development_programs")

  advancementReference: BasicGovEmployeeProfile
    @canQuery(ability: "viewAnyBasicGovEmployeeProfile", model: "User")
  advancementReferenceReview: LocalizedTalentNominationUserReview
    @rename(attribute: "advancement_reference_review")
  advancementReferenceFallbackWorkEmail: String
    @rename(attribute: "advancement_reference_fallback_work_email")
  advancementReferenceFallbackName: String
    @rename(attribute: "advancement_reference_fallback_name")
  advancementReferenceFallbackClassification: Classification @belongsTo
  advancementReferenceFallbackDepartment: Department @belongsTo

  lateralMovementOptions: [LocalizedTalentNominationLateralMovementOption!]
    @rename(attribute: "lateral_movement_options")
  lateralMovementOptionsOther: String
    @rename(attribute: "lateral_movement_options_other")

  developmentPrograms: [DevelopmentProgram!] @belongsToMany
  developmentProgramOptionsOther: String
    @rename(attribute: "development_program_options_other")

  nominationRationale: String @rename(attribute: "nomination_rationale")
  skills: [Skill] @belongsToMany
  additionalComments: String @rename(attribute: "additional_comments")
}

type Team implements HasRoleAssignments {
  id: ID!
  name: String! # represents a unique key for a team
  displayName: LocalizedString @rename(attribute: "display_name")
  description: LocalizedString
  departments: [Department] @belongsToMany
  contactEmail: Email @rename(attribute: "contact_email")
  pools: [Pool] @hasMany @canResolved(ability: "view")
  teamable: HasRoleAssignments @morphTo @canRoot(ability: "viewTeamable")
  roleAssignments: [RoleAssignment!]
    @hasMany
    @canRoot(ability: "viewTeamMembers")
  teamIdForRoleAssignment: ID @rename(attribute: "id")
}

type Role {
  id: ID!
  name: String! # represents a unique key for a role
  displayName: LocalizedString @rename(attribute: "display_name")
  description: LocalizedString
  isTeamBased: Boolean @rename(attribute: "is_team_based")
  roleAssignments: [RoleAssignment!]
    @hasMany
    @canModel(ability: "viewAnyRoleAssignments", model: "Role")
}

# This model represents the polymorphic role_user table and allows querying the team relationship
type RoleAssignment {
  id: ID!
  role: Role @belongsTo
  teamable: HasRoleAssignments @guard # Returns the related team, if it has a teamable returns that instead, guarded in the accessor
  team: Team @belongsTo
  user: UserPublicProfile @morphTo
}

# equity selections goes with the pool/applicant filters and not user model
type EquitySelections {
  isWoman: Boolean @rename(attribute: "is_woman")
  hasDisability: Boolean @rename(attribute: "has_disability")
  isIndigenous: Boolean @rename(attribute: "is_indigenous")
  isVisibleMinority: Boolean @rename(attribute: "is_visible_minority")
}

input EquitySelectionsInput {
  isWoman: Boolean @rename(attribute: "is_woman")
  hasDisability: Boolean @rename(attribute: "has_disability")
  isVisibleMinority: Boolean @rename(attribute: "is_visible_minority")
  isIndigenous: Boolean @rename(attribute: "is_indigenous")
}

type PoolCandidateFilter {
  id: ID!
  classifications: [Classification] @belongsToMany
  hasDiploma: Boolean @rename(attribute: "has_diploma")
  equity: EquitySelections
  languageAbility: LocalizedLanguageAbility
    @rename(attribute: "language_ability")
  operationalRequirements: [LocalizedOperationalRequirement]
    @rename(attribute: "operational_requirements")
  workRegions: [LocalizedWorkRegion] @rename(attribute: "work_regions")
  pools: [Pool] @belongsToMany @canResolved(ability: "view")
}

# ApplicantFilter only includes the fields which Talent Seekers can use to search for candidates.
type ApplicantFilter {
  id: ID!
  hasDiploma: Boolean @rename(attribute: "has_diploma")
  equity: EquitySelections
  languageAbility: LocalizedLanguageAbility
    @rename(attribute: "language_ability")
  operationalRequirements: [LocalizedOperationalRequirement]
    @rename(attribute: "operational_requirements")
  locationPreferences: [LocalizedWorkRegion]
    @rename(attribute: "location_preferences")
  positionDuration: [PositionDuration] @rename(attribute: "position_duration")
  skills: [Skill] @belongsToMany
  # request creation connects to qualifiedClassifications
  qualifiedClassifications: [Classification] @belongsToMany # Filters applicants based on the classifications pools they've qualified in.
  workStreams: [WorkStream!] @belongsToMany # Filters applicants based on the streams of the pools they've qualified in.
  pools: [Pool] @belongsToMany @canResolved(ability: "view")
  community: Community @belongsTo # Currently does not affect search, scope needs to be added
}

type PoolCandidateSearchRequest {
  id: ID!
  fullName: String @rename(attribute: "full_name")
  email: Email
  department: Department @belongsTo
  jobTitle: String @rename(attribute: "job_title")
  additionalComments: String @rename(attribute: "additional_comments")
  hrAdvisorEmail: Email @rename(attribute: "hr_advisor_email")
  requestedDate: DateTime @rename(attribute: "created_at")
  status: LocalizedPoolCandidateSearchStatus
    @rename(attribute: "request_status")
  statusChangedAt: DateTime @rename(attribute: "request_status_changed_at")
  adminNotes: String @rename(attribute: "admin_notes")
  poolCandidateFilter: PoolCandidateFilter
    @belongsTo
    @deprecated(reason: "Replaced by applicantFilter")
  applicantFilter: ApplicantFilter @belongsTo
  wasEmpty: Boolean @rename(attribute: "was_empty")
  managerJobTitle: String @rename(attribute: "manager_job_title")
  positionType: LocalizedPoolCandidateSearchPositionType
    @rename(attribute: "position_type")
  reason: LocalizedPoolCandidateSearchRequestReason
  community: Community @belongsTo
  initialResultCount: Int @rename(attribute: "initial_result_count")
}

type SkillFamily {
  id: ID!
  key: KeyString!
  name: LocalizedString
  description: LocalizedString
  skills: [Skill!] @belongsToMany
}

type Skill {
  id: ID!
  key: KeyString!
  name: LocalizedString!
  description: LocalizedString
  keywords: SkillKeywords
  category: LocalizedSkillCategory!
  families: [SkillFamily!] @belongsToMany

  # ExperienceSkillRecord is the pivot data and may only be queried when Skill is nested in an Experience (eg. experience->skill->experienceSkillRecord). Querying for it otherwise will just return null.
  experienceSkillRecord: ExperienceSkillRecord
    @rename(attribute: "experience_skill")
}

type UserSkill {
  id: ID!
  user: User! @belongsTo @canResolved(ability: "view")
  skill: Skill! @belongsTo
  skillLevel: SkillLevel @rename(attribute: "skill_level")
  whenSkillUsed: WhenSkillUsed @rename(attribute: "when_skill_used")
  topSkillsRank: Int @rename(attribute: "top_skills_rank")
  improveSkillsRank: Int @rename(attribute: "improve_skills_rank")
  # Experiences
  experiences: [Experience!] @belongsToMany
}

type SkillKeywords {
  en: [String!]
  fr: [String!]
}

interface Experience {
  id: ID!
  details: String
  skills: [Skill!] @hasMany
  # ExperienceSkillRecord is the pivot data and may only be queried when Experience is nested in a Skill (eg. skill->experiences->experienceSkillRecord). Querying for it otherwise will just return null.
  experienceSkillRecord: ExperienceSkillRecord
    @rename(attribute: "experience_skill")
  deletedDate: DateTime @rename(attribute: "deleted_at")
}

type WorkExperience implements Experience {
  id: ID!
  user: User! @belongsTo(relation: "user") @canResolved(ability: "view")
  role: String
  organization: String
  division: String
  startDate: Date @rename(attribute: "start_date")
  endDate: Date @rename(attribute: "end_date")
  details: String
  skills: [Skill!] @hasMany
  # ExperienceSkillRecord is the pivot data and may only be queried when Experience is nested in a Skill (eg. skill->experiences->experienceSkillRecord). Querying for it otherwise will just return null.
  experienceSkillRecord: ExperienceSkillRecord
    @rename(attribute: "experience_skill")
  deletedDate: DateTime @rename(attribute: "deleted_at")
  employmentCategory: LocalizedEmploymentCategory
    @rename(attribute: "employment_category")
  extSizeOfOrganization: LocalizedExternalSizeOfOrganization
    @rename(attribute: "ext_size_of_organization")
  extRoleSeniority: LocalizedExternalRoleSeniority
    @rename(attribute: "ext_role_seniority")
  govEmploymentType: LocalizedWorkExperienceGovEmployeeType
    @rename(attribute: "gov_employment_type")
  govPositionType: LocalizedGovPositionType
    @rename(attribute: "gov_position_type")
  govContractorRoleSeniority: LocalizedGovContractorRoleSeniority
    @rename(attribute: "gov_contractor_role_seniority")
  govContractorType: LocalizedGovContractorType
    @rename(attribute: "gov_contractor_type")
  contractorFirmAgencyName: String
    @rename(attribute: "contractor_firm_agency_name")
  cafEmploymentType: LocalizedCafEmploymentType
    @rename(attribute: "caf_employment_type")
  cafForce: LocalizedCafForce @rename(attribute: "caf_force")
  cafRank: LocalizedCafRank @rename(attribute: "caf_rank")
  classification: Classification @with(relation: "classification")
  department: Department @with(relation: "department")
  workStreams: [WorkStream!] @with(relation: "workStreams")
  supervisoryPosition: Boolean
  supervisedEmployees: Boolean
  supervisedEmployeesNumber: String
  budgetManagement: Boolean
  annualBudgetAllocation: String
  seniorManagementStatus: Boolean
  cSuiteRoleTitle: LocalizedCSuiteRoleTitle
    @rename(attribute: "c_suite_role_title")
  otherCSuiteRoleTitle: String
}
type PersonalExperience implements Experience {
  id: ID!
  user: User! @belongsTo(relation: "user") @canResolved(ability: "view")
  title: String
  description: String
  startDate: Date @rename(attribute: "start_date")
  endDate: Date @rename(attribute: "end_date")
  details: String
  skills: [Skill!] @hasMany
  # ExperienceSkillRecord is the pivot data and may only be queried when Experience is nested in a Skill (eg. skill->experiences->experienceSkillRecord). Querying for it otherwise will just return null.
  experienceSkillRecord: ExperienceSkillRecord
    @rename(attribute: "experience_skill")
  deletedDate: DateTime @rename(attribute: "deleted_at")
}
type CommunityExperience implements Experience {
  id: ID!
  user: User! @belongsTo(relation: "user") @canResolved(ability: "view")
  title: String
  organization: String
  project: String
  startDate: Date @rename(attribute: "start_date")
  endDate: Date @rename(attribute: "end_date")
  details: String
  skills: [Skill!] @hasMany
  # ExperienceSkillRecord is the pivot data and must be queried through a nested mutation (eg. experience->skill->experienceSkillRecord) querying for it directly will just return null
  experienceSkillRecord: ExperienceSkillRecord
    @rename(attribute: "experience_skill")
  deletedDate: DateTime @rename(attribute: "deleted_at")
}
type EducationExperience implements Experience {
  id: ID!
  user: User! @belongsTo(relation: "user") @canResolved(ability: "view")
  institution: String
  areaOfStudy: String @rename(attribute: "area_of_study")
  thesisTitle: String @rename(attribute: "thesis_title")
  startDate: Date @rename(attribute: "start_date")
  endDate: Date @rename(attribute: "end_date")
  type: LocalizedEducationType
  status: LocalizedEducationStatus
  details: String
  skills: [Skill!] @hasMany
  # ExperienceSkillRecord is the pivot data and may only be queried when Experience is nested in a Skill (eg. skill->experiences->experienceSkillRecord). Querying for it otherwise will just return null.
  experienceSkillRecord: ExperienceSkillRecord
    @rename(attribute: "experience_skill")
  deletedDate: DateTime @rename(attribute: "deleted_at")
}
type AwardExperience implements Experience {
  id: ID!
  user: User! @belongsTo(relation: "user") @canResolved(ability: "view")
  title: String
  issuedBy: String @rename(attribute: "issued_by")
  awardedDate: Date @rename(attribute: "awarded_date")
  awardedTo: LocalizedAwardedTo @rename(attribute: "awarded_to")
  awardedScope: LocalizedAwardedScope @rename(attribute: "awarded_scope")
  details: String
  skills: [Skill!] @hasMany
  # ExperienceSkillRecord is the pivot data and may only be queried when Experience is nested in a Skill (eg. skill->experiences->experienceSkillRecord). Querying for it otherwise will just return null.
  experienceSkillRecord: ExperienceSkillRecord
    @rename(attribute: "experience_skill")
  deletedDate: DateTime @rename(attribute: "deleted_at")
}

type ExperienceSkillRecord {
  details: String
}

type JobPosterTemplate {
  id: UUID!
  referenceId: String @rename(attribute: "reference_id")
  name: LocalizedString
  description: LocalizedString
  supervisoryStatus: LocalizedSupervisoryStatus
    @rename(attribute: "supervisory_status")
  workDescription: LocalizedString @rename(attribute: "work_description")
  tasks: LocalizedString
  keywords: LocalizedKeywords
  essentialTechnicalSkillsNotes: LocalizedString
    @rename(attribute: "essential_technical_skills_notes")
  essentialBehaviouralSkillsNotes: LocalizedString
    @rename(attribute: "essential_behavioural_skills_notes")
  nonessentialTechnicalSkillsNotes: LocalizedString
    @rename(attribute: "nonessential_technical_skills_notes")

  classification: Classification @belongsTo
  workStream: WorkStream @belongsTo
  skills: [JobPosterTemplateSkill!] @belongsToMany(model: "Skill")
}

type LocalizedKeywords {
  en: [String!]
  fr: [String!]
}

type JobPosterTemplateSkillPivot {
  type: LocalizedPoolSkillType!
  requiredLevel: SkillLevel @rename(attribute: "required_skill_level")
}

type JobPosterTemplateSkill {
  id: UUID!
  skill: Skill! @self
  pivot: JobPosterTemplateSkillPivot
}

input ClassificationFilterInput {
  group: String!
  level: Int!
}

input KeyFilterInput {
  key: KeyString!
}

input IdInput {
  id: ID!
}

input UserPoolFilterInput {
  poolId: ID!
  expiryStatus: CandidateExpiryFilter = ACTIVE
  statuses: [PoolCandidateStatus!]
  suspendedStatus: CandidateSuspendedFilter = ACTIVE
}

input UserFilterInput {
  applicantFilter: ApplicantFilterInput @spread
  poolFilters: [UserPoolFilterInput] @scope(name: "poolFilters")
  isProfileComplete: Boolean @scope
  isGovEmployee: Boolean @scope
  telephone: String @scope
  email: String @scope
  workEmail: String @scope
  name: String @scope
  generalSearch: String @scope
  roles: [ID] @scope(name: "roleAssignments")
  trashed: Trashed @trashed
}

input UserPublicProfileFilterInput {
  publicProfileSearch: String @scope
}

input PoolFilterInput {
  generalSearch: String @scope
  name: String @scope
  team: String @scope
  workStreams: [UUID!] @scope(name: "whereWorkStreamsIn")
  statuses: [PoolStatus!] = [] @scope
  processNumber: String @scope
  publishingGroups: [PublishingGroup!] @scope
  classifications: [ClassificationFilterInput!]
    @scope(name: "whereClassifications")
  canAdmin: Boolean @scope
}

input PoolTeamDisplayNameOrderByInput {
  locale: String!
  order: SortOrder!
}

input PoolWorkStreamNameOrderByInput {
  locale: String!
  order: SortOrder!
}

input PoolBookmarksOrderByInput {
  column: String!
  order: SortOrder!
}

input OrderByColumnInput {
  column: String!
  order: SortOrder!
  nulls: NullsOption
}

# Changes to this input will require some manual updates to api/app/GraphQL/Queries/CountPoolCandidatesByPool.php since it doesn't use the directives for automatic resolution
input ApplicantFilterInput {
  equity: EquitySelectionsInput @scope
  hasDiploma: Boolean @scope
  languageAbility: LanguageAbility @scope
  locationPreferences: [WorkRegion] @scope
  operationalRequirements: [OperationalRequirement] @scope
  positionDuration: [PositionDuration] @scope
  # This field is [IdInput] instead of [ID] so that the output of an ApplicantFilter query can be used directly.
  pools: [IdInput] @scope(name: "availableInPools") @pluck(key: "id")
  skills: [IdInput] @scope(name: "skillsAdditive") @pluck(key: "id") # main one to correspond with ApplicantFilter.php
  skillsIntersectional: [IdInput] @scope @pluck(key: "id") # AND filtering skills as opposed to OR
  qualifiedClassifications: [ClassificationFilterInput]
    @scope(name: "qualifiedClassifications") # Filters applicants based on the classification of pools they are currently qualified and available in.
  workStreams: [IdInput] @scope(name: "qualifiedStreams") # Filters applicants based on the stream of pools they are currently qualified and available in.
  community: IdInput @scope(name: "candidatesInCommunity") @pluck(key: "id")
}

input PoolCandidateSearchInput {
  applicantFilter: ApplicantFilterInput @spread
  email: String @scope
  generalSearch: String @scope
  name: String @scope
  notes: String @scope
  isGovEmployee: Boolean @scope
  priorityWeight: [PriorityWeight] @scope(name: "candidateCategory")
  poolCandidateStatus: [PoolCandidateStatus]
    @scope(name: "poolCandidateStatuses")
  expiryStatus: CandidateExpiryFilter @scope(name: "expiryStatus")
  suspendedStatus: CandidateSuspendedFilter @scope(name: "suspendedStatus")
  publishingGroups: [PublishingGroup] @scope(name: "publishingGroups") # Filters applicants based on the publishing group of the pool
  # Filters applicants based on the classification of all pools they are currently in.
  # There is also a classification field as part of ApplicantFilterInput however it includes scoping for availability.
  appliedClassifications: [ClassificationFilterInput]
    @scope(name: "appliedClassifications")
  processNumber: String @scope(name: "processNumber")
}

input PoolCandidateSearchRequestInput {
  status: [PoolCandidateSearchStatus] @scope(name: "searchRequestStatus")
  departments: [ID] @scope
  classifications: [ID] @scope
  workStreams: [UUID] @scope
  fullName: String @scope
  email: String @scope
  id: ID @scope
  jobTitle: String @scope
  additionalComments: String @scope
  hrAdvisorEmail: String @scope
  adminNotes: String @scope
  generalSearch: String @scope
}

input PoolCandidatePoolNameOrderByInput {
  locale: String!
  order: SortOrder!
}

type CandidateSearchPoolResult {
  pool: Pool! @canResolved(ability: "view")
  candidateCount: Int! @rename(attribute: "candidate_count")
}

type SitewideAnnouncement {
  isEnabled: Boolean!
  publishDate: DateTime!
  expiryDate: DateTime!
  title: LocalizedString!
  message: LocalizedString!
}

type TrainingOpportunity {
  id: UUID!
  title: LocalizedString
  courseLanguage: LocalizedCourseLanguage @rename(attribute: "course_language")
  registrationDeadline: Date @rename(attribute: "registration_deadline")
  registrationDeadlineStatus: LocalizedDeadlineStatus
  trainingStart: Date @rename(attribute: "training_start")
  trainingEnd: Date @rename(attribute: "training_end")
  description: LocalizedString
  applicationUrl: LocalizedString @rename(attribute: "application_url")
  courseFormat: LocalizedCourseFormat @rename(attribute: "course_format")
}

input TrainingOpportunitiesFilterInput {
  hidePassedRegistrationDeadline: Boolean @scope
  opportunityLanguage: CourseLanguage @scope
}

input SitewideAnnouncementInput {
  isEnabled: Boolean!
  publishDate: DateTime!
  expiryDate: DateTime! @rules(apply: ["after:publishDate"])
  title: LocalizedStringInput!
  message: LocalizedStringInput!
}

input ClaimVerificationSort {
  order: SortOrder!
  useBookmark: Boolean
}

input CommunityInterestFilterInput {
  userName: String @scope
}

type Query {
  myAuth: UserAuthInfo @auth
  me: User @auth
  user(id: UUID! @eq): User @find @softDeletes @guard @canQuery(ability: "view")
  govEmployeeProfile(
    workEmail: String! @scope(name: "exactWorkEmail")
  ): BasicGovEmployeeProfile
    @guard
    @validator
    @find(model: "App\\Models\\User", scopes: ["isVerifiedGovEmployee"])
  usersPaginated(
    where: UserFilterInput
    orderBy: [OrderByClause!] @orderBy
  ): [User]!
    @orderBy(column: "created_at", direction: DESC)
    @paginate(defaultCount: 10, maxCount: 1000, scopes: ["authorizedToView"])
    @guard
    @canResolved(ability: "view")
  userPublicProfilesPaginated(
    where: UserPublicProfileFilterInput
    excludeIds: [ID!] @notIn(key: "id")
    orderBy: [OrderByClause!] @orderBy
  ): [UserPublicProfile]!
    @orderBy(column: "created_at", direction: DESC)
    @paginate(
      defaultCount: 10
      maxCount: 1000
      scopes: ["authorizedToViewBasicInfo"]
    )
    @guard
    @canModel(ability: "viewBasicInfo", model: "User")
  # countApplicants returns the number of candidates matching its filters, and requires no special permissions.
  countApplicants(where: ApplicantFilterInput): Int!
    @count(model: "User", scopes: ["talentSearchablePublishingGroup"])
  pool(id: UUID! @eq): Pool @find @canQuery(ability: "view")
  publishedPools(
    closingAfter: DateTime @where(key: "closing_date", operator: ">")
    publishingGroup: PublishingGroup
      @where(key: "publishing_group", operator: "=")
  ): [Pool!]!
    @all(scopes: ["wherePublished", "whereNotArchived"])
    @canModel(ability: "viewAnyPublished", model: "Pool")
  pools: [Pool]!
    @all(scopes: ["authorizedToView", "whereNotArchived"])
    @canResolved(ability: "view")
    @deprecated(reason: "pools is deprecated. Use poolsPaginated instead.")
  poolsPaginated(
    includeIds: [UUID!] @in(key: "id")
    excludeIds: [UUID!] @notIn(key: "id")
    where: PoolFilterInput
    orderByPoolBookmarks: PoolBookmarksOrderByInput @scope
    orderByTeamDisplayName: PoolTeamDisplayNameOrderByInput @scope
    orderByWorkStreamName: PoolWorkStreamNameOrderByInput @scope
    orderByColumn: OrderByColumnInput @scope
    orderBy: _
      @orderBy(
        relations: [
          { relation: "user", columns: ["first_name", "email"] }
          { relation: "classification", columns: ["group", "level"] }
        ]
      )
  ): [Pool]!
    @paginate(defaultCount: 10, maxCount: 1000, scopes: ["authorizedToView"])
    @canResolved(ability: "view")
  poolCandidate(id: UUID! @eq): PoolCandidate
    @find
    @guard
    @canQuery(ability: "view")
  poolCandidatesPaginated(
    where: PoolCandidateSearchInput
    orderByPoolName: PoolCandidatePoolNameOrderByInput @scope
    orderByClaimVerification: ClaimVerificationSort @scope
    orderBy: _
      @orderBy(
        relations: [
          {
            relation: "user"
            columns: [
              "priority_weight"
              "first_name"
              "email"
              "preferred_lang"
              "preferred_language_for_interview"
              "preferred_language_for_exam"
              "current_city"
            ]
          }
          { relation: "pool", columns: ["process_number"] }
        ]
      )
      @with(
        relations: [
          "user:id,first_name,last_name,email,preferred_lang"
          "pool:id,process_number"
          "skills:id,name"
        ]
      ) # Limit fields for eager loading
  ): [PoolCandidateWithSkillCount]!
    @guard
    @paginate(
      defaultCount: 10
      maxCount: 1000
      scopes: ["notDraft", "withSkillCount", "authorizedToView"]
      model: "App\\Models\\PoolCandidate"
    )
  # This query lives at api/app/GraphQL/Queries/CountPoolCandidatesByPool.php.
  # Returns the number of candidates by filtering their parent applicant, grouped by pool.
  countPoolCandidatesByPool(
    where: ApplicantFilterInput
  ): [CandidateSearchPoolResult!]!
  classification(id: UUID! @eq): Classification @find @canModel(ability: "view")
  classifications(availableInSearch: Boolean @scope): [Classification]!
    @all
    @canModel(ability: "viewAny")
  department(id: UUID! @eq): Department @find @canModel(ability: "view")
  departments: [Department]! @all @canModel(ability: "viewAny")
  jobPosterTemplate(id: UUID! @eq): JobPosterTemplate
    @find
    @canFind(ability: "view", find: "id")
  jobPosterTemplates: [JobPosterTemplate!] @all @canModel(ability: "viewAny")
  poolCandidateSearchRequest(id: ID! @eq): PoolCandidateSearchRequest
    @find
    @guard
    @canQuery(ability: "view")
  poolCandidateSearchRequestsPaginated(
    where: PoolCandidateSearchRequestInput
    orderBy: [OrderByClause!] @orderBy
  ): [PoolCandidateSearchRequest]!
    @orderBy(column: "created_at", direction: DESC)
    @paginate(defaultCount: 10, maxCount: 500, scopes: ["authorizedToView"])
    @guard
    @canResolved(ability: "view")
  skillFamily(id: UUID! @eq): SkillFamily @find @canModel(ability: "view")
  skillFamilies: [SkillFamily]! @all @canModel(ability: "viewAny")
  skill(id: UUID! @eq): Skill @find @canModel(ability: "view")
  skills: [Skill]! @all @canModel(ability: "viewAny")
  genericJobTitle(id: UUID! @eq): GenericJobTitle
    @find
    @canModel(ability: "view")
  genericJobTitles: [GenericJobTitle]! @all @canModel(ability: "viewAny")

  community(id: UUID! @eq): Community @find @canQuery(ability: "view")
  communities: [Community]! @all @canModel(ability: "viewAny")
  team(id: UUID! @eq): Team @find @canQuery(ability: "view")
  teams: [Team]! @all @canModel(ability: "viewAny")
  roles: [Role]! @all @canModel(ability: "viewAny")
  workStream(id: UUID! @eq): WorkStream @find @canQuery(ability: "view")
  workStreams: [WorkStream]! @all @canModel(ability: "viewAny")

  notifications(
    where: NotificationFilterInput
    excludeIds: [UUID!] @notIn(key: "id")
  ): [Notification!]
    @orderBy(column: "created_at", direction: DESC)
    @paginate(defaultCount: 10, scopes: ["authorizedToView"])

  sitewideAnnouncement: SitewideAnnouncement
  talentNominationEvents(
    status: TalentNominationEventStatus @scope
  ): [TalentNominationEvent]!
    @all
    @orderBy(column: "close_date", direction: ASC)

  talentNomination(id: UUID! @eq): TalentNomination
    @find
    @guard
    @canQuery(ability: "view")
  trainingOpportunity(id: UUID! @eq): TrainingOpportunity @find
  trainingOpportunitiesPaginated(
    where: TrainingOpportunitiesFilterInput
    orderBy: [OrderByClause!] @orderBy
  ): [TrainingOpportunity]
    @paginate(
      defaultCount: 10
      maxCount: 1000
      model: "App\\Models\\TrainingOpportunity"
    )

  localizedEnumStrings(
    enumName: String!
      @rules(apply: ["required", "App\\Rules\\LocalizedEnumExists"])
  ): [LocalizedEnumString!]
  communityInterestsPaginated(
    where: CommunityInterestFilterInput
    orderBy: _
      @orderBy(
        relations: [
          {
            relation: "user"
            columns: ["first_name", "work_email", "preferred_lang"]
          }
        ]
      )
  ): [CommunityInterest]!
    @guard
    @paginate(defaultCount: 10, maxCount: 500, scopes: ["authorizedToView"])
}

input ClassificationBelongsTo {
  connect: ID
  disconnect: Boolean
}
input PoolsHasMany {
  create: [CreatePoolInput]
}
"""
When creating a User, name is required.
"""
input CreateUserInput {
  sub: String
    @rules(
      apply: ["sometimes", "unique:users,sub"]
      messages: [{ rule: "unique", message: "CreateUserSubInUse" }]
    )

  # Personal info
  firstName: String! @rename(attribute: "first_name")
  lastName: String! @rename(attribute: "last_name")
  email: Email
    @lowerCase
    @rules(
      apply: [
        "sometimes"
        "nullable"
        "unique:users,email"
        "unique:users,work_email"
      ]
      messages: [{ rule: "unique", message: "CreateUserEmailInUse" }]
    )
  telephone: PhoneNumber
  preferredLang: Language @rename(attribute: "preferred_lang")
  preferredLanguageForInterview: Language
    @rename(attribute: "preferred_language_for_interview")
  preferredLanguageForExam: Language
    @rename(attribute: "preferred_language_for_exam")
  currentProvince: ProvinceOrTerritory @rename(attribute: "current_province")
  currentCity: String @rename(attribute: "current_city")
  citizenship: CitizenshipStatus
  armedForcesStatus: ArmedForcesStatus @rename(attribute: "armed_forces_status")

  # Language
  lookingForEnglish: Boolean @rename(attribute: "looking_for_english")
  lookingForFrench: Boolean @rename(attribute: "looking_for_french")
  lookingForBilingual: Boolean @rename(attribute: "looking_for_bilingual")
  firstOfficialLanguage: Language @rename(attribute: "first_official_language")
  secondLanguageExamCompleted: Boolean
    @rename(attribute: "second_language_exam_completed")
  secondLanguageExamValidity: Boolean
    @rename(attribute: "second_language_exam_validity")
  comprehensionLevel: EvaluatedLanguageAbility
    @rename(attribute: "comprehension_level")
  writtenLevel: EvaluatedLanguageAbility @rename(attribute: "written_level")
  verbalLevel: EvaluatedLanguageAbility @rename(attribute: "verbal_level")
  estimatedLanguageAbility: EstimatedLanguageAbility
    @rename(attribute: "estimated_language_ability")

  # Gov info
  isGovEmployee: Boolean @rename(attribute: "computed_is_gov_employee")
  workEmail: Email
    @rename(attribute: "work_email")
    @lowerCase
    @rules(
      apply: [
        "sometimes"
        "nullable"
        "unique:users,email"
        "unique:users,work_email"
      ]
      messages: [{ rule: "unique", message: "CreateUserEmailInUse" }]
    )
  govEmployeeType: GovEmployeeType
    @rename(attribute: "computed_gov_employee_type")
  currentClassification: ClassificationBelongsTo
  department: DepartmentBelongsTo
  hasPriorityEntitlement: Boolean @rename(attribute: "has_priority_entitlement")
  priorityNumber: String @rename(attribute: "priority_number")

  # Employment equity
  isWoman: Boolean @rename(attribute: "is_woman")
  hasDisability: Boolean @rename(attribute: "has_disability")
  isVisibleMinority: Boolean @rename(attribute: "is_visible_minority")
  indigenousCommunities: [IndigenousCommunity]
    @rename(attribute: "indigenous_communities")
  indigenousDeclarationSignature: String
    @rename(attribute: "indigenous_declaration_signature")

  # Applicant info
  hasDiploma: Boolean @rename(attribute: "has_diploma")
  locationPreferences: [WorkRegion] @rename(attribute: "location_preferences")
  locationExemptions: String @rename(attribute: "location_exemptions")
  acceptedOperationalRequirements: [OperationalRequirement]
    @rename(attribute: "accepted_operational_requirements")
  positionDuration: [PositionDuration] @rename(attribute: "position_duration")

  # Experiences
  workExperiences: WorkExperienceHasMany
  personalExperiences: PersonalExperienceHasMany
  communityExperiences: CommunityExperienceHasMany
  educationExperiences: EducationExperienceHasMany
  awardExperiences: AwardExperienceHasMany
}
"""
When updating a User, all fields are optional
"""
input UpdateUserAsAdminInput @validator {
  id: ID

  # Personal info
  email: Email @lowerCase
  firstName: String @rename(attribute: "first_name")
  lastName: String @rename(attribute: "last_name")
  telephone: PhoneNumber
  preferredLang: Language @rename(attribute: "preferred_lang")
  preferredLanguageForInterview: Language
    @rename(attribute: "preferred_language_for_interview")
  preferredLanguageForExam: Language
    @rename(attribute: "preferred_language_for_exam")
  currentProvince: ProvinceOrTerritory @rename(attribute: "current_province")
  currentCity: String @rename(attribute: "current_city")
  citizenship: CitizenshipStatus
  armedForcesStatus: ArmedForcesStatus @rename(attribute: "armed_forces_status")

  # Language
  lookingForEnglish: Boolean @rename(attribute: "looking_for_english")
  lookingForFrench: Boolean @rename(attribute: "looking_for_french")
  lookingForBilingual: Boolean @rename(attribute: "looking_for_bilingual")
  firstOfficialLanguage: Language @rename(attribute: "first_official_language")
  secondLanguageExamCompleted: Boolean
    @rename(attribute: "second_language_exam_completed")
  secondLanguageExamValidity: Boolean
    @rename(attribute: "second_language_exam_validity")
  comprehensionLevel: EvaluatedLanguageAbility
    @rename(attribute: "comprehension_level")
  writtenLevel: EvaluatedLanguageAbility @rename(attribute: "written_level")
  verbalLevel: EvaluatedLanguageAbility @rename(attribute: "verbal_level")
  estimatedLanguageAbility: EstimatedLanguageAbility
    @rename(attribute: "estimated_language_ability")

  # Gov info
  isGovEmployee: Boolean @rename(attribute: "computed_is_gov_employee")
  workEmail: Email @rename(attribute: "work_email") @lowerCase
  govEmployeeType: GovEmployeeType
    @rename(attribute: "computed_gov_employee_type")
  currentClassification: ClassificationBelongsTo
  department: DepartmentBelongsTo
  hasPriorityEntitlement: Boolean @rename(attribute: "has_priority_entitlement")
  priorityNumber: String @rename(attribute: "priority_number")

  # Employment equity
  isWoman: Boolean @rename(attribute: "is_woman")
  hasDisability: Boolean @rename(attribute: "has_disability")
  isVisibleMinority: Boolean @rename(attribute: "is_visible_minority")
  indigenousCommunities: [IndigenousCommunity]
    @rename(attribute: "indigenous_communities")
  indigenousDeclarationSignature: String
    @rename(attribute: "indigenous_declaration_signature")

  # Applicant info
  hasDiploma: Boolean @rename(attribute: "has_diploma")
  locationPreferences: [WorkRegion] @rename(attribute: "location_preferences")
  locationExemptions: String @rename(attribute: "location_exemptions")
  acceptedOperationalRequirements: [OperationalRequirement]
    @rename(attribute: "accepted_operational_requirements")
  positionDuration: [PositionDuration] @rename(attribute: "position_duration")

  # Experiences
  workExperiences: WorkExperienceHasMany
  personalExperiences: PersonalExperienceHasMany
  communityExperiences: CommunityExperienceHasMany
  educationExperiences: EducationExperienceHasMany
  awardExperiences: AwardExperienceHasMany
}

input UpdateUserSubInput {
  userId: UUID! @rename(attribute: "id")
  sub: String!
}

input UpdateUserRolesInput {
  userId: UUID! @rename(attribute: "id")
  roleAssignmentsInput: RoleAssignmentHasMany!
}

input UpdateUserAsUserInput @validator {
  id: ID
  # Personal info
  email: Email @lowerCase
  firstName: String @rename(attribute: "first_name")
  lastName: String @rename(attribute: "last_name")
  telephone: PhoneNumber
  preferredLang: Language @rename(attribute: "preferred_lang")
  preferredLanguageForInterview: Language
    @rename(attribute: "preferred_language_for_interview")
  preferredLanguageForExam: Language
    @rename(attribute: "preferred_language_for_exam")
  currentProvince: ProvinceOrTerritory @rename(attribute: "current_province")
  currentCity: String @rename(attribute: "current_city")
  citizenship: CitizenshipStatus
  armedForcesStatus: ArmedForcesStatus @rename(attribute: "armed_forces_status")

  # Language
  lookingForEnglish: Boolean @rename(attribute: "looking_for_english")
  lookingForFrench: Boolean @rename(attribute: "looking_for_french")
  lookingForBilingual: Boolean @rename(attribute: "looking_for_bilingual")
  firstOfficialLanguage: Language @rename(attribute: "first_official_language")
  secondLanguageExamCompleted: Boolean
    @rename(attribute: "second_language_exam_completed")
  secondLanguageExamValidity: Boolean
    @rename(attribute: "second_language_exam_validity")
  comprehensionLevel: EvaluatedLanguageAbility
    @rename(attribute: "comprehension_level")
  writtenLevel: EvaluatedLanguageAbility @rename(attribute: "written_level")
  verbalLevel: EvaluatedLanguageAbility @rename(attribute: "verbal_level")
  estimatedLanguageAbility: EstimatedLanguageAbility
    @rename(attribute: "estimated_language_ability")

  # Gov info
  isGovEmployee: Boolean @rename(attribute: "computed_is_gov_employee")
  workEmail: Email @rename(attribute: "work_email") @lowerCase
  govEmployeeType: GovEmployeeType
    @rename(attribute: "computed_gov_employee_type")
  currentClassification: ClassificationBelongsTo
  department: DepartmentBelongsTo
  hasPriorityEntitlement: Boolean @rename(attribute: "has_priority_entitlement")
  priorityNumber: String @rename(attribute: "priority_number")

  # Employment equity
  isWoman: Boolean @rename(attribute: "is_woman")
  hasDisability: Boolean @rename(attribute: "has_disability")
  isVisibleMinority: Boolean @rename(attribute: "is_visible_minority")
  indigenousCommunities: [IndigenousCommunity]
    @rename(attribute: "indigenous_communities")
  indigenousDeclarationSignature: String
    @rename(attribute: "indigenous_declaration_signature")

  # Applicant info
  hasDiploma: Boolean @rename(attribute: "has_diploma")
  locationPreferences: [WorkRegion] @rename(attribute: "location_preferences")
  locationExemptions: String @rename(attribute: "location_exemptions")
  acceptedOperationalRequirements: [OperationalRequirement]
    @rename(attribute: "accepted_operational_requirements")
  positionDuration: [PositionDuration] @rename(attribute: "position_duration")

  # Experiences
  workExperiences: WorkExperienceHasMany
  personalExperiences: PersonalExperienceHasMany
  communityExperiences: CommunityExperienceHasMany
  educationExperiences: EducationExperienceHasMany
  awardExperiences: AwardExperienceHasMany
}

input UpdateEmployeeProfileInput @validator {
  lateralMoveInterest: Boolean
    @rename(attribute: "career_planning_lateral_move_interest")
  lateralMoveTimeFrame: TimeFrame
    @rename(attribute: "career_planning_lateral_move_time_frame")
  lateralMoveOrganizationType: [OrganizationTypeInterest!]
    @rename(attribute: "career_planning_lateral_move_organization_type")

  promotionMoveInterest: Boolean
    @rename(attribute: "career_planning_promotion_move_interest")
  promotionMoveTimeFrame: TimeFrame
    @rename(attribute: "career_planning_promotion_move_time_frame")
  promotionMoveOrganizationType: [OrganizationTypeInterest!]
    @rename(attribute: "career_planning_promotion_move_organization_type")

  mentorshipStatus: [Mentorship!]
    @rename(attribute: "career_planning_mentorship_status")
  mentorshipInterest: [Mentorship!]
    @rename(attribute: "career_planning_mentorship_interest")
  execInterest: Boolean @rename(attribute: "career_planning_exec_interest")
  execCoachingStatus: [ExecCoaching!]
    @rename(attribute: "career_planning_exec_coaching_status")
  execCoachingInterest: [ExecCoaching!]
    @rename(attribute: "career_planning_exec_coaching_interest")
  aboutYou: String @rename(attribute: "career_planning_about_you")
  learningGoals: String @rename(attribute: "career_planning_learning_goals")
  workStyle: String @rename(attribute: "career_planning_work_style")
  nextRoleJobTitle: String @rename(attribute: "next_role_job_title")
  careerObjectiveJobTitle: String
    @rename(attribute: "career_objective_job_title")
  nextRoleAdditionalInformation: String
    @rename(attribute: "next_role_additional_information")
  careerObjectiveAdditionalInformation: String
    @rename(attribute: "career_objective_additional_information")
  nextRoleCommunity: CommunityBelongsTo
  careerObjectiveCommunity: CommunityBelongsTo
  nextRoleCommunityOther: String @rename(attribute: "next_role_community_other")
  careerObjectiveCommunityOther: String
    @rename(attribute: "career_objective_community_other")
  nextRoleClassification: ClassificationBelongsTo
  careerObjectiveClassification: ClassificationBelongsTo
  nextRoleWorkStreams: WorkStreamBelongsToMany
  careerObjectiveWorkStreams: WorkStreamBelongsToMany
  nextRoleDepartments: DepartmentBelongsToMany
  careerObjectiveDepartments: DepartmentBelongsToMany
  nextRoleTargetRole: TargetRole @rename(attribute: "next_role_target_role")
  careerObjectiveTargetRole: TargetRole
    @rename(attribute: "career_objective_target_role")
  nextRoleTargetRoleOther: String
    @rename(attribute: "next_role_target_role_other")
  careerObjectiveTargetRoleOther: String
    @rename(attribute: "career_objective_target_role_other")

  nextRoleIsCSuiteRole: Boolean @rename(attribute: "next_role_is_c_suite_role")
  careerObjectiveIsCSuiteRole: Boolean
    @rename(attribute: "career_objective_is_c_suite_role")
  nextRoleCSuiteRoleTitle: CSuiteRoleTitle
    @rename(attribute: "next_role_c_suite_role_title")
  careerObjectiveCSuiteRoleTitle: CSuiteRoleTitle
    @rename(attribute: "career_objective_c_suite_role_title")
}

input CreateCommunityInterestInput @validator {
  userId: UUID! @rename(attribute: "user_id")
  community: CommunityBelongsTo!
  workStreams: WorkStreamBelongsToMany
  jobInterest: Boolean @rename(attribute: "job_interest")
  trainingInterest: Boolean @rename(attribute: "training_interest")
  additionalInformation: String @rename(attribute: "additional_information")
  interestInDevelopmentPrograms: CreateDevelopmentProgramInterestHasMany
}

input UpdateCommunityInterestInput @validator {
  # Usually the ID parameter is at the mutation level but we need it here for the validator.
  id: UUID!
  workStreams: WorkStreamBelongsToMany
  jobInterest: Boolean @rename(attribute: "job_interest")
  trainingInterest: Boolean @rename(attribute: "training_interest")
  additionalInformation: String @rename(attribute: "additional_information")
  interestInDevelopmentPrograms: UpdateDevelopmentProgramInterestHasMany
}

input CreateDevelopmentProgramInterestHasMany {
  create: [CreateDevelopmentProgramInterestInput!]
}

input UpdateDevelopmentProgramInterestHasMany {
  create: [CreateDevelopmentProgramInterestInput!]
  update: [UpdateDevelopmentProgramInterestInput!]
  delete: [UUID!]
}

input CreateDevelopmentProgramInterestInput @validator {
  developmentProgramId: UUID! @rename(attribute: "development_program_id")
  participationStatus: DevelopmentProgramParticipationStatus
    @rename(attribute: "participation_status")
  completionDate: Date @rename(attribute: "completion_date")
}

input UpdateDevelopmentProgramInterestInput @validator {
  id: UUID!
  participationStatus: DevelopmentProgramParticipationStatus
    @rename(attribute: "participation_status")
  completionDate: Date @rename(attribute: "completion_date")
}

input LocalizedStringInput {
  en: String
  fr: String
}

input UserBelongsTo {
  connect: ID
}

input PoolBelongsTo {
  connect: ID!
}

input TeamBelongsTo {
  connect: ID!
}

input CreateClassificationInput {
  name: LocalizedStringInput
  group: String!
  level: Int!
  minSalary: Int
    @rename(attribute: "min_salary")
    @rules(apply: ["numeric", "min:0"])
  maxSalary: Int
    @rename(attribute: "max_salary")
    @rules(apply: ["numeric", "min:0", "gte:minSalary"])
}

input ClassificationBelongsToMany {
  sync: [ID!]
}

input CreatePoolCandidateAsAdminInput {
  pool: PoolBelongsTo!
  user: UserBelongsTo!
  expiryDate: Date @rename(attribute: "expiry_date")
  status: PoolCandidateStatus = NEW_APPLICATION
    @rename(attribute: "pool_candidate_status")
  notes: String
  isBookmarked: Boolean
}

input UpdateClassificationInput {
  name: LocalizedStringInput
  group: String
  minSalary: Int
    @rename(attribute: "min_salary")
    @rules(apply: ["numeric", "min:0"])
  maxSalary: Int
    @rename(attribute: "max_salary")
    @rules(apply: ["numeric", "min:0", "gte:minSalary"])
}

input UpdatePoolCandidateStatusInput {
  expiryDate: Date @rename(attribute: "expiry_date")
  status: PoolCandidateStatus @rename(attribute: "pool_candidate_status")
}

input UpdatePoolCandidateClaimVerificationInput @validator {
  veteranVerification: ClaimVerificationResult
    @rename(attribute: "veteran_verification")
  veteranVerificationExpiry: Date
    @rename(attribute: "veteran_verification_expiry")
  priorityVerification: ClaimVerificationResult
    @rename(attribute: "priority_verification")
  priorityVerificationExpiry: Date
    @rename(attribute: "priority_verification_expiry")
}

input PlaceCandidateInput {
  placementType: PlacementType!
  departmentId: UUID!
}

input CreateDepartmentInput {
  departmentNumber: Int!
    @rename(attribute: "department_number")
    @rules(
      apply: ["unique:departments,department_number"]
      messages: [{ rule: "unique", message: "DepartmentNumberInUse" }]
    )
  name: LocalizedStringInput
}

input UpdateDepartmentInput {
  departmentNumber: Int @rename(attribute: "department_number")
  name: LocalizedStringInput
}

input DepartmentBelongsTo {
  connect: ID
  disconnect: Boolean
}

input DepartmentBelongsToMany {
  sync: [ID!]
}

input CreateWorkStreamInput {
  key: String
  name: LocalizedStringInput!
  plainLanguageName: LocalizedStringInput
    @rename(attribute: "plain_language_name")
  community: CommunityBelongsTo!
}

input UpdateWorkStreamInput {
  key: String
  name: LocalizedStringInput
  plainLanguageName: LocalizedStringInput
    @rename(attribute: "plain_language_name")
  community: CommunityBelongsTo
}

input WorkStreamBelongsTo {
  connect: ID
  disconnect: Boolean
}

input WorkStreamBelongsToMany {
  sync: [ID!]
}

input PoolBelongsToMany {
  sync: [ID!]
}

input CommunityBelongsTo {
  connect: UUID
  disconnect: Boolean
}

input CreateTeamInput {
  name: String!
    @rules(
      apply: ["unique:teams,name"]
      messages: [{ rule: "unique", message: "TeamNameInUse" }]
    )
  displayName: LocalizedStringInput @rename(attribute: "display_name")
  description: LocalizedStringInput
  departments: DepartmentBelongsToMany
  contactEmail: Email @rename(attribute: "contact_email")
}

input UpdateTeamInput {
  name: String
  displayName: LocalizedStringInput @rename(attribute: "display_name")
  description: LocalizedStringInput
  departments: DepartmentBelongsToMany
  contactEmail: Email @rename(attribute: "contact_email")
}

input CreateCommunityInput {
  key: String!
  name: LocalizedStringInput
  description: LocalizedStringInput
  mandateAuthority: LocalizedStringInput @rename(attribute: "mandate_authority")
}

input UpdateCommunityInput {
  key: String
  name: LocalizedStringInput
  description: LocalizedStringInput
  mandateAuthority: LocalizedStringInput @rename(attribute: "mandate_authority")
}

input DevelopmentProgramBelongsToMany {
  sync: [UUID!]
}

input CreateTalentNominationEventInput @validator {
  name: LocalizedStringInput!
  description: LocalizedStringInput
  openDate: DateTime! @rename(attribute: "open_date")
  closeDate: DateTime! @rename(attribute: "close_date")
  learnMoreUrl: LocalizedStringInput @rename(attribute: "learn_more_url")
  includeLeadershipCompetencies: Boolean
    @rename(attribute: "include_leadership_competencies")
  community: CommunityBelongsTo!
  developmentPrograms: DevelopmentProgramBelongsToMany
}

input UpdateTalentNominationEventInput @validator {
  name: LocalizedStringInput
  description: LocalizedStringInput
  openDate: DateTime @rename(attribute: "open_date")
  closeDate: DateTime @rename(attribute: "close_date")
  learnMoreUrl: LocalizedStringInput @rename(attribute: "learn_more_url")
  includeLeadershipCompetencies: Boolean
    @rename(attribute: "include_leadership_competencies")
  community: CommunityBelongsTo
  developmentPrograms: DevelopmentProgramBelongsToMany
}

input TalentNominationEventBelongsTo {
  connect: ID
  # no need for disconnect at the moment
}

input CreateTalentNominationInput @validator {
  talentNominationEvent: TalentNominationEventBelongsTo!
  submitterRelationshipToNominator: TalentNominationSubmitterRelationshipToNominator
    @rename(attribute: "submitter_relationship_to_nominator")
  submitterRelationshipToNominatorOther: String
    @rename(attribute: "submitter_relationship_to_nominator_other")
  nominator: UserBelongsTo
  nominatorFallbackWorkEmail: String
    @rename(attribute: "nominator_fallback_work_email")
  nominatorFallbackName: String @rename(attribute: "nominator_fallback_name")
  nominatorFallbackClassification: ClassificationBelongsTo
  nominatorFallbackDepartment: DepartmentBelongsTo
  nominatorReview: TalentNominationUserReview
    @rename(attribute: "nominator_review")
  nominee: UserBelongsTo
  nomineeReview: TalentNominationUserReview @rename(attribute: "nominee_review")
  nomineeRelationshipToNominator: TalentNominationNomineeRelationshipToNominator
    @rename(attribute: "nominee_relationship_to_nominator")
  nomineeRelationshipToNominatorOther: String
    @rename(attribute: "nominee_relationship_to_nominator_other")

  nominateForAdvancement: Boolean @rename(attribute: "nominate_for_advancement")
  nominateForLateralMovement: Boolean
    @rename(attribute: "nominate_for_lateral_movement")
  nominateForDevelopmentPrograms: Boolean
    @rename(attribute: "nominate_for_development_programs")

  advancementReference: UserBelongsTo
  advancementReferenceReview: TalentNominationUserReview
    @rename(attribute: "advancement_reference_review")
  advancementReferenceFallbackWorkEmail: String
    @rename(attribute: "advancement_reference_fallback_work_email")
  advancementReferenceFallbackName: String
    @rename(attribute: "advancement_reference_fallback_name")
  advancementReferenceFallbackClassification: ClassificationBelongsTo
  advancementReferenceFallbackDepartment: DepartmentBelongsTo

  lateralMovementOptions: [TalentNominationLateralMovementOption!]
    @rename(attribute: "lateral_movement_options")
  lateralMovementOptionsOther: String
    @rename(attribute: "lateral_movement_options_other")

  developmentPrograms: DevelopmentProgramBelongsToMany
  developmentProgramOptionsOther: String
    @rename(attribute: "development_program_options_other")

  nominationRationale: String @rename(attribute: "nomination_rationale")
  skills: SkillBelongsToMany
  additionalComments: String @rename(attribute: "additional_comments")
}

input UpdateTalentNominationInput @validator {
  # can only connect a step, not disconnect or sync
  insertSubmittedStep: TalentNominationStep
  submitterRelationshipToNominator: TalentNominationSubmitterRelationshipToNominator
    @rename(attribute: "submitter_relationship_to_nominator")
  submitterRelationshipToNominatorOther: String
    @rename(attribute: "submitter_relationship_to_nominator_other")
  nominator: UserBelongsTo
  nominatorFallbackWorkEmail: String
    @rename(attribute: "nominator_fallback_work_email")
  nominatorFallbackName: String @rename(attribute: "nominator_fallback_name")
  nominatorFallbackClassification: ClassificationBelongsTo
  nominatorFallbackDepartment: DepartmentBelongsTo
  nominatorReview: TalentNominationUserReview
    @rename(attribute: "nominator_review")
  nominee: UserBelongsTo
  nomineeReview: TalentNominationUserReview @rename(attribute: "nominee_review")
  nomineeRelationshipToNominator: TalentNominationNomineeRelationshipToNominator
    @rename(attribute: "nominee_relationship_to_nominator")
  nomineeRelationshipToNominatorOther: String
    @rename(attribute: "nominee_relationship_to_nominator_other")

  nominateForAdvancement: Boolean @rename(attribute: "nominate_for_advancement")
  nominateForLateralMovement: Boolean
    @rename(attribute: "nominate_for_lateral_movement")
  nominateForDevelopmentPrograms: Boolean
    @rename(attribute: "nominate_for_development_programs")

  advancementReference: UserBelongsTo
  advancementReferenceReview: TalentNominationUserReview
    @rename(attribute: "advancement_reference_review")
  advancementReferenceFallbackWorkEmail: String
    @rename(attribute: "advancement_reference_fallback_work_email")
  advancementReferenceFallbackName: String
    @rename(attribute: "advancement_reference_fallback_name")
  advancementReferenceFallbackClassification: ClassificationBelongsTo
  advancementReferenceFallbackDepartment: DepartmentBelongsTo

  lateralMovementOptions: [TalentNominationLateralMovementOption!]
    @rename(attribute: "lateral_movement_options")
  lateralMovementOptionsOther: String
    @rename(attribute: "lateral_movement_options_other")

  developmentPrograms: DevelopmentProgramBelongsToMany
  developmentProgramOptionsOther: String
    @rename(attribute: "development_program_options_other")

  nominationRationale: String @rename(attribute: "nomination_rationale")
  skills: SkillBelongsToMany
  additionalComments: String @rename(attribute: "additional_comments")
}

input CreateApplicantFilterInput {
  hasDiploma: Boolean @rename(attribute: "has_diploma")
  equity: EquitySelectionsInput @spread
  languageAbility: LanguageAbility @rename(attribute: "language_ability")
  operationalRequirements: [OperationalRequirement]
    @rename(attribute: "operational_requirements")
  locationPreferences: [WorkRegion] @rename(attribute: "location_preferences")
  positionDuration: [PositionDuration] @rename(attribute: "position_duration")
  skills: SkillBelongsToMany
  pools: PoolBelongsToMany
  citizenship: CitizenshipStatus
  armedForcesStatus: ArmedForcesStatus @rename(attribute: "armed_forces_status")
  qualifiedClassifications: ClassificationBelongsToMany
  workStreams: WorkStreamBelongsToMany
  community: CommunityBelongsTo
}

input ApplicantFilterBelongsTo {
  create: CreateApplicantFilterInput!
}

input CreatePoolCandidateSearchRequestInput {
  fullName: String! @rename(attribute: "full_name")
  email: Email!
  department: DepartmentBelongsTo!
  community: CommunityBelongsTo!
  jobTitle: String! @rename(attribute: "job_title")
  additionalComments: String @rename(attribute: "additional_comments")
  hrAdvisorEmail: Email @rename(attribute: "hr_advisor_email")
  applicantFilter: ApplicantFilterBelongsTo!
  # status will be set to NEW by default in Postgres
  wasEmpty: Boolean @rename(attribute: "was_empty")
  managerJobTitle: String! @rename(attribute: "manager_job_title")
  positionType: PoolCandidateSearchPositionType!
    @rename(attribute: "position_type")
  reason: PoolCandidateSearchRequestReason!
  initialResultCount: Int @rename(attribute: "initial_result_count")
}

input UpdatePoolCandidateSearchRequestInput {
  adminNotes: String @rename(attribute: "admin_notes")
  status: PoolCandidateSearchStatus
  # statusChangedAt updated in the Eloquent model
}

input SkillBelongsToMany {
  sync: [ID!]
}
input SkillBelongsTo {
  connect: ID!
}

input CreateSkillFamilyInput {
  key: KeyString!
    @rules(
      apply: ["unique:skill_families,key"]
      messages: [{ rule: "unique", message: "SkillFamilyKeyStringInUse" }]
    )
  name: LocalizedStringInput!
  description: LocalizedStringInput
  skills: SkillBelongsToMany
}

input UpdateSkillFamilyInput {
  name: LocalizedStringInput
  description: LocalizedStringInput
  skills: SkillBelongsToMany
}

input SkillFamilyBelongsToMany {
  sync: [ID!]
}

input SkillKeywordsInput {
  en: [String!]
  fr: [String!]
}

input CreateSkillInput {
  key: KeyString!
    @rules(
      apply: ["unique:skills,key"]
      messages: [{ rule: "unique", message: "SkillKeyStringInUse" }]
    )
  name: LocalizedStringInput!
  description: LocalizedStringInput
  families: SkillFamilyBelongsToMany
  keywords: SkillKeywordsInput
  category: SkillCategory!
}

input UpdateSkillInput {
  name: LocalizedStringInput!
  description: LocalizedStringInput
  families: SkillFamilyBelongsToMany
  keywords: SkillKeywordsInput
  category: SkillCategory
}

input WorkExperienceInput {
  role: String
  organization: String
  division: String
  startDate: Date @rename(attribute: "start_date")
  endDate: Date @rename(attribute: "end_date")
  details: String
  skills: UpdateExperienceSkills @spread
  employmentCategory: EmploymentCategory
    @rename(attribute: "employment_category")
  extSizeOfOrganization: ExternalSizeOfOrganization
    @rename(attribute: "ext_size_of_organization")
  extRoleSeniority: ExternalRoleSeniority
    @rename(attribute: "ext_role_seniority")
  govEmploymentType: WorkExperienceGovEmployeeType
    @rename(attribute: "gov_employment_type")
  govPositionType: GovPositionType @rename(attribute: "gov_position_type")
  govContractorRoleSeniority: GovContractorRoleSeniority
    @rename(attribute: "gov_contractor_role_seniority")
  govContractorType: GovContractorType @rename(attribute: "gov_contractor_type")
  cafEmploymentType: CafEmploymentType @rename(attribute: "caf_employment_type")
  contractorFirmAgencyName: String
    @rename(attribute: "contractor_firm_agency_name")
  cafForce: CafForce @rename(attribute: "caf_force")
  cafRank: CafRank @rename(attribute: "caf_rank")
  classificationId: String @rename(attribute: "classification_id")
  departmentId: String @rename(attribute: "department_id")
  workStreamIds: [UUID!] @rename(attribute: "work_stream_ids")
  supervisoryPosition: Boolean @rename(attribute: "supervisory_position")
  supervisedEmployees: Boolean @rename(attribute: "supervised_employees")
  supervisedEmployeesNumber: String
    @rename(attribute: "supervised_employees_number")
  budgetManagement: Boolean @rename(attribute: "budget_management")
  annualBudgetAllocation: String @rename(attribute: "annual_budget_allocation")
  seniorManagementStatus: Boolean @rename(attribute: "senior_management_status")
  cSuiteRoleTitle: CSuiteRoleTitle @rename(attribute: "c_suite_role_title")
  otherCSuiteRoleTitle: String @rename(attribute: "other_c_suite_role_title")
}
input PersonalExperienceInput {
  title: String
  description: String
  startDate: Date @rename(attribute: "start_date")
  endDate: Date @rename(attribute: "end_date")
  details: String
  skills: UpdateExperienceSkills @spread
}
input CommunityExperienceInput {
  title: String
  organization: String
  project: String
  startDate: Date @rename(attribute: "start_date")
  endDate: Date @rename(attribute: "end_date")
  details: String
  skills: UpdateExperienceSkills @spread
}
input EducationExperienceInput {
  institution: String
  areaOfStudy: String @rename(attribute: "area_of_study")
  thesisTitle: String @rename(attribute: "thesis_title")
  startDate: Date @rename(attribute: "start_date")
  endDate: Date @rename(attribute: "end_date")
  type: EducationType
  status: EducationStatus
  details: String
  skills: UpdateExperienceSkills @spread
}
input AwardExperienceInput {
  title: String
  issuedBy: String @rename(attribute: "issued_by")
  awardedDate: Date @rename(attribute: "awarded_date")
  awardedTo: AwardedTo @rename(attribute: "awarded_to")
  awardedScope: AwardedScope @rename(attribute: "awarded_scope")
  details: String
  skills: UpdateExperienceSkills @spread
}

input UpdateExperienceSkills {
  connect: [ConnectExperienceSkills!] @resolveWith(method: "connectSkills")
  # This is an alias of connect since it is a custom command that can do both (insert and update)
  # It is here to avoid confusion when using it on the frontend
  update: [ConnectExperienceSkills!] @resolveWith(method: "connectSkills")
  disconnect: [ID!] @resolveWith(method: "disconnectSkills")
  sync: [ConnectExperienceSkills!] @resolveWith(method: "syncSkills")
}

input ConnectExperienceSkills {
  id: ID!
  details: String
}

input CreateUserSkillInput {
  skillLevel: SkillLevel @rename(attribute: "skill_level")
  whenSkillUsed: WhenSkillUsed @rename(attribute: "when_skill_used")
}

input UpdateUserSkillInput {
  skillLevel: SkillLevel @rename(attribute: "skill_level")
  whenSkillUsed: WhenSkillUsed @rename(attribute: "when_skill_used")
}

input UpdateUserSkillRankingsInput {
  # array of skill ids
  topTechnicalSkillsRanked: [UUID]
    @rulesForArray(apply: ["nullable", "App\\Rules\\ArrayIsUnique"])
  topBehaviouralSkillsRanked: [UUID]
    @rulesForArray(apply: ["nullable", "App\\Rules\\ArrayIsUnique"])
  improveTechnicalSkillsRanked: [UUID]
    @rulesForArray(apply: ["nullable", "App\\Rules\\ArrayIsUnique"])
  improveBehaviouralSkillsRanked: [UUID]
    @rulesForArray(apply: ["nullable", "App\\Rules\\ArrayIsUnique"])
}

input WorkExperienceHasMany {
  create: [WorkExperienceInput!]
}
input PersonalExperienceHasMany {
  create: [PersonalExperienceInput!]
}
input CommunityExperienceHasMany {
  create: [CommunityExperienceInput!]
}
input EducationExperienceHasMany {
  create: [EducationExperienceInput!]
}
input AwardExperienceHasMany {
  create: [AwardExperienceInput!]
}
input GenericJobTitleBelongsToMany {
  sync: [ID!]
}

input CreatePoolInput {
  classification: ClassificationBelongsTo
  department: DepartmentBelongsTo!
}

input DuplicatePoolInput {
  departmentId: ID
}

input CreateGeneralQuestionInput {
  question: LocalizedStringInput!
  sortOrder: Int @rename(attribute: "sort_order")
}

input UpdateGeneralQuestionInput {
  id: ID!
  question: LocalizedStringInput
  sortOrder: Int @rename(attribute: "sort_order")
}

input UpdateGeneralQuestionsHasMany {
  create: [CreateGeneralQuestionInput!]
  update: [UpdateGeneralQuestionInput!]
  delete: [ID!]
}

input SyncScreeningQuestionsInput {
  id: ID
  question: LocalizedStringInput!
  sortOrder: Int
}

input UpdatePoolInput {
  # Pool name and classification
  name: LocalizedStringInput
  classification: ClassificationBelongsTo
  department: DepartmentBelongsTo
  workStream: WorkStreamBelongsTo
  processNumber: String @rename(attribute: "process_number")
  # Closing date
  closingDate: DateTime
    @rename(attribute: "closing_date")
    @rules(
      apply: ["after:today"]
      messages: [{ rule: "after", message: "UpdatePoolClosingDate" }]
    )
  closingReason: String @rename(attribute: "closing_reason")
  # Your impact
  yourImpact: LocalizedStringInput @rename(attribute: "your_impact")
  # Work Tasks
  keyTasks: LocalizedStringInput @rename(attribute: "key_tasks")
  # What to expect
  whatToExpect: LocalizedStringInput @rename(attribute: "what_to_expect")
  # Special note
  specialNote: LocalizedStringInput @rename(attribute: "special_note")
  # What to expect after admission
  whatToExpectAdmission: LocalizedStringInput
    @rename(attribute: "what_to_expect_admission")
  # About us (team, department, etc.)
  aboutUs: LocalizedStringInput @rename(attribute: "about_us")
  # Other requirements
  language: PoolLanguage @rename(attribute: "advertisement_language")
  securityClearance: SecurityStatus @rename(attribute: "security_clearance")
  location: LocalizedStringInput @rename(attribute: "advertisement_location")
  isRemote: Boolean @rename(attribute: "is_remote")
  publishingGroup: PublishingGroup @rename(attribute: "publishing_group")
  opportunityLength: PoolOpportunityLength
    @rename(attribute: "opportunity_length")
  generalQuestions: UpdateGeneralQuestionsHasMany
  areaOfSelection: PoolAreaOfSelection @rename(attribute: "area_of_selection")
  selectionLimitations: [PoolSelectionLimitation!]
    @rename(attribute: "selection_limitations")
}

input UpdatePublishedPoolInput @validator {
  changeJustification: String! @rename(attribute: "change_justification")
  yourImpact: LocalizedStringInput @rename(attribute: "your_impact")
  keyTasks: LocalizedStringInput @rename(attribute: "key_tasks")
  whatToExpect: LocalizedStringInput @rename(attribute: "what_to_expect")
  specialNote: LocalizedStringInput @rename(attribute: "special_note")
  whatToExpectAdmission: LocalizedStringInput
    @rename(attribute: "what_to_expect_admission")
  aboutUs: LocalizedStringInput @rename(attribute: "about_us")
}

input CreatePoolSkillInput @validator {
  poolId: ID! @rename(attribute: "pool_id")
  skillId: ID! @rename(attribute: "skill_id")
  type: PoolSkillType!
  requiredLevel: SkillLevel @rename(attribute: "required_skill_level")
}

input UpdatePoolSkillInput {
  requiredLevel: SkillLevel @rename(attribute: "required_skill_level")
}

input AssessmentStepInput {
  type: AssessmentStepType
    @rules(
      apply: ["notIn:APPLICATION_SCREENING"]
      messages: [{ rule: "not_in", message: "InvalidAssessmentTypeSelection" }]
    )
  title: LocalizedStringInput
  poolSkills: PoolSkillBelongsToMany
}

input ScreeningQuestionAssessmentStepInput {
  title: LocalizedStringInput
  poolSkills: PoolSkillBelongsToMany
}

input CreateAssessmentResultInput
  @validator(
    class: "App\\GraphQL\\Validators\\CreateAssessmentResultInputValidator"
  ) {
  assessmentStepId: UUID! @rename(attribute: "assessment_step_id")
  poolCandidateId: UUID! @rename(attribute: "pool_candidate_id")
  poolSkillId: UUID @rename(attribute: "pool_skill_id")
  assessmentResultType: AssessmentResultType
    @rename(attribute: "assessment_result_type")
  assessmentDecision: AssessmentDecision
    @rename(attribute: "assessment_decision")
  justifications: [AssessmentResultJustification]
  assessmentDecisionLevel: AssessmentDecisionLevel
    @rename(attribute: "assessment_decision_level")
  skillDecisionNotes: String @rename(attribute: "skill_decision_notes")
}

input UpdateAssessmentResultInput
  @validator(
    class: "App\\GraphQL\\Validators\\UpdateAssessmentResultInputValidator"
  ) {
  id: UUID!
  assessmentResultType: AssessmentResultType
    @rename(attribute: "assessment_result_type")
  assessmentDecision: AssessmentDecision
    @rename(attribute: "assessment_decision")
  justifications: [AssessmentResultJustification]
  assessmentDecisionLevel: AssessmentDecisionLevel
    @rename(attribute: "assessment_decision_level")
  skillDecisionNotes: String @rename(attribute: "skill_decision_notes")
}
input CreateTrainingOpportunityInput {
  title: LocalizedStringInput!
  courseLanguage: CourseLanguage! @rename(attribute: "course_language")
  registrationDeadline: Date! @rename(attribute: "registration_deadline")
  trainingStart: Date! @rename(attribute: "training_start")
  trainingEnd: Date @rename(attribute: "training_end")
  description: LocalizedStringInput!
  applicationUrl: LocalizedStringInput! @rename(attribute: "application_url")
  courseFormat: CourseFormat! @rename(attribute: "course_format")
}

input UpdateTrainingOpportunityInput {
  id: UUID!
  title: LocalizedStringInput
  courseLanguage: CourseLanguage @rename(attribute: "course_language")
  registrationDeadline: Date @rename(attribute: "registration_deadline")
  trainingStart: Date @rename(attribute: "training_start")
  trainingEnd: Date @rename(attribute: "training_end")
  description: LocalizedStringInput
  applicationUrl: LocalizedStringInput @rename(attribute: "application_url")
  courseFormat: CourseFormat @rename(attribute: "course_format")
}

input PoolSkillBelongsToMany {
  sync: [UUID!]!
}

input RoleInput {
  roleId: ID!
  teamId: ID
}

input RoleAssignmentHasMany
  @validator(class: "App\\GraphQL\\Validators\\RoleInputValidator") {
  attach: [RoleInput]
  detach: [RoleInput]
}

# This input only accepts Team-Based roles. It is assumed that a team id will be provided at a higher level of input.
input RolesForTeamInput
  @validator(class: "App\\GraphQL\\Validators\\TeamRolesInputValidator") {
  roles: [ID!]
}

input RolesForTeamHasMany {
  attach: RolesForTeamInput
  detach: RolesForTeamInput
  sync: RolesForTeamInput
}

input GeneralResponseBelongsTo {
  connect: ID!
}

input CreateGeneralQuestionResponseInput {
  generalQuestion: GeneralResponseBelongsTo!
  answer: String!
}

input UpdateGeneralQuestionResponseInput {
  id: ID!
  answer: String
}

input UpdateGeneralQuestionResponsesHasMany {
  create: [CreateGeneralQuestionResponseInput!]
  update: [UpdateGeneralQuestionResponseInput!]
  delete: [ID!]
}

input ScreeningResponseBelongsTo {
  connect: ID!
}

input CreateScreeningQuestionResponseInput {
  screeningQuestion: ScreeningResponseBelongsTo!
  answer: String!
}

input UpdateScreeningQuestionResponseInput {
  id: ID!
  answer: String
}

input UpdateScreeningQuestionResponsesHasMany {
  create: [CreateScreeningQuestionResponseInput!]
  update: [UpdateScreeningQuestionResponseInput!]
  delete: [ID!]
}

input UpdateEducationExperiencesRequirementBelongsToMany {
  sync: [ID!]
}

input UpdateApplicationInput {
  # can only connect a step, not disconnect or sync
  insertSubmittedStep: ApplicationStep
  generalQuestionResponses: UpdateGeneralQuestionResponsesHasMany
  screeningQuestionResponses: UpdateScreeningQuestionResponsesHasMany
  educationRequirementOption: EducationRequirementOption
    @rename(attribute: "education_requirement_option")
  # experiences for meeting minimum criteria
  educationRequirementExperiences: UpdateEducationExperiencesRequirementBelongsToMany

  # Used to validate essential skills
  applicationId: ID
    @rename(attribute: "id")
    @rules(apply: ["App\\Rules\\HasEssentialSkills"])
}

input DateRange {
  from: DateTime!
  to: DateTime! @rules(apply: ["after_or_equal:from"])
}

input LocalizedKeywordsInput {
  en: [String!]
  fr: [String!]
}

input NotificationFilterInput {
  onlyUnread: Boolean @scope
  readAt: DateRange @whereBetween(key: "read_at")
  createdAt: DateRange @whereBetween(key: "created_at")
}

input ConnectJobPosterTemplateSkillInput {
  id: UUID!
  type: PoolSkillType!
  requiredLevel: SkillLevel @rename(attribute: "required_skill_level")
}

input SyncJobPosterTemplateSkillInput {
  id: UUID!
  type: PoolSkillType
  requiredLevel: SkillLevel @rename(attribute: "required_skill_level")
}

input UpdateJobPosterTemplateSkillsInput {
  connect: [ConnectJobPosterTemplateSkillInput!]
  sync: [SyncJobPosterTemplateSkillInput!]
  detach: [UUID!]
}

input CreateJobPosterTemplateInput @validator {
  referenceId: String! @rename(attribute: "reference_id")
  name: LocalizedStringInput!
  description: LocalizedStringInput!
  supervisoryStatus: SupervisoryStatus! @rename(attribute: "supervisory_status")
  workStream: WorkStreamBelongsTo!
  workDescription: LocalizedStringInput @rename(attribute: "work_description")
  tasks: LocalizedStringInput!
  keywords: LocalizedKeywordsInput
  essentialTechnicalSkillsNotes: LocalizedStringInput
    @rename(attribute: "essential_technical_skills_notes")
  essentialBehaviouralSkillsNotes: LocalizedStringInput
    @rename(attribute: "essential_behavioural_skills_notes")
  nonessentialTechnicalSkillsNotes: LocalizedStringInput
    @rename(attribute: "nonessential_technical_skills_notes")
  classification: ClassificationBelongsTo!
  skills: UpdateJobPosterTemplateSkillsInput
}

input UpdateJobPosterTemplateInput @validator {
  id: UUID!
  referenceId: String @rename(attribute: "reference_id")
  name: LocalizedStringInput
  description: LocalizedStringInput
  supervisoryStatus: SupervisoryStatus @rename(attribute: "supervisory_status")
  workStream: WorkStreamBelongsTo
  workDescription: LocalizedStringInput @rename(attribute: "work_description")
  tasks: LocalizedStringInput
  keywords: LocalizedStringInput
  essentialTechnicalSkillsNotes: LocalizedStringInput
    @rename(attribute: "essential_technical_skills_notes")
  essentialBehaviouralSkillsNotes: LocalizedStringInput
    @rename(attribute: "essential_behavioural_skills_notes")
  nonessentialTechnicalSkillsNotes: LocalizedStringInput
    @rename(attribute: "nonessential_technical_skills_notes")
  classification: ClassificationBelongsTo
  skills: UpdateJobPosterTemplateSkillsInput
}

type Mutation {
  # User mutations
  createUser(user: CreateUserInput! @spread): User
    @create
    @guard
    @canModel(ability: "create")
    @throttle(maxAttempts: 100)
  updateUserAsUser(id: ID!, user: UpdateUserAsUserInput! @spread): User
    @update
    @guard
    @canFind(ability: "update", find: "id", injectArgs: true)
  updateUserAsAdmin(id: ID!, user: UpdateUserAsAdminInput! @spread): User
    @update
    @guard
    @canFind(ability: "update", find: "id", injectArgs: true)
  updateUserSub(updateUserSubInput: UpdateUserSubInput! @spread): UserAuthInfo
    @update(model: "User")
    @canModel(ability: "updateSub", model: "User")
  updateUserRoles(
    updateUserRolesInput: UpdateUserRolesInput! @spread
  ): UserAuthInfo
    @guard
    @update(model: "User")
    @canModel(ability: "updateRoles", model: "User", injectArgs: true)
  updateEmployeeProfile(
    id: UUID!
    employeeProfile: UpdateEmployeeProfileInput! @spread
  ): EmployeeProfile
    @guard
    @update(model: "EmployeeProfile")
    @canFind(ability: "update", find: "id", model: "EmployeeProfile")
  createCommunityInterest(
    communityInterest: CreateCommunityInterestInput! @spread
  ): CommunityInterest
    @guard
    @create
    @canModel(ability: "create", injectArgs: true)
  updateCommunityInterest(
    communityInterest: UpdateCommunityInterestInput! @spread
  ): CommunityInterest
    @guard
    @update(model: "CommunityInterest")
    @canFind(ability: "update", find: "id", model: "CommunityInterest")
  deleteCommunityInterest(id: UUID! @whereKey): CommunityInterest
    @delete
    @guard
    @canFind(ability: "delete", find: "id")
  deleteUser(id: ID! @whereKey): User
    @delete
    @guard
    @canFind(ability: "delete", find: "id")
  restoreUser(id: ID! @whereKey): User
    @restore
    @guard
    @canFind(ability: "restore", find: "id")
  sendUserEmailVerification(emailType: EmailType): User @guard
  verifyUserEmail(emailType: EmailType, code: String!): User @guard

  # poolCandidate mutations
  createPoolCandidateAsAdmin(
    poolCandidate: CreatePoolCandidateAsAdminInput! @spread
  ): PoolCandidate
    @create
    @guard
    @canModel(ability: "create")
    @injectNow(name: "submitted_at")
  updatePoolCandidateStatus(
    id: UUID!
    poolCandidate: UpdatePoolCandidateStatusInput! @spread
  ): PoolCandidate
    @guard
    @canFind(ability: "updateStatus", find: "id", injectArgs: true)
  # Return a boolean to prevent automatically updating the client's cache
  togglePoolCandidateBookmark(id: ID!): Boolean
    @guard
    @canFind(
      ability: "updateBookmark"
      find: "id"
      model: "PoolCandidate"
      injectArgs: true
    )
  updatePoolCandidateClaimVerification(
    id: UUID!
    poolCandidate: UpdatePoolCandidateClaimVerificationInput! @spread
  ): PoolCandidate @update @guard @canFind(ability: "updateNotes", find: "id")
  updatePoolCandidateNotes(id: UUID!, notes: String): PoolCandidate
    @update
    @guard
    @canFind(ability: "updateNotes", find: "id")
  removeCandidate(
    id: UUID!
    removalReason: CandidateRemovalReason!
    removalReasonOther: String
  ): PoolCandidate
    @guard
    @canFind(ability: "updateDecision", find: "id", injectArgs: true)
  reinstateCandidate(id: UUID!): PoolCandidate
    @guard
    @canFind(ability: "updateDecision", find: "id", injectArgs: true)
  deletePoolCandidate(id: ID! @whereKey): PoolCandidate
    @delete
    @guard
    @canFind(ability: "delete", find: "id")
  qualifyCandidate(id: UUID!, expiryDate: Date!): PoolCandidate
    @guard
    @canFind(ability: "updateDecision", find: "id", injectArgs: true)
    @validator(class: "App\\GraphQL\\Validators\\QualifyCandidateValidator")
  disqualifyCandidate(
    id: UUID!
    reason: DisqualificationReason!
  ): PoolCandidate
    @guard
    @canFind(ability: "updateDecision", find: "id", injectArgs: true)
    @validator(class: "App\\GraphQL\\Validators\\DisqualifyCandidateValidator")
  revertFinalDecision(id: UUID!): PoolCandidate
    @guard
    @canFind(ability: "updateDecision", find: "id", injectArgs: true)
    @validator(class: "App\\GraphQL\\Validators\\RevertFinalDecisionValidator")
  placeCandidate(
    id: UUID!
    placeCandidate: PlaceCandidateInput! @spread
  ): PoolCandidate
    @guard
    @canFind(ability: "updatePlacement", find: "id", injectArgs: true)
    @validator(class: "App\\GraphQL\\Validators\\PlaceCandidateValidator")
  revertPlaceCandidate(id: UUID!): PoolCandidate
    @guard
    @canFind(ability: "updatePlacement", find: "id", injectArgs: true)
    @validator(class: "App\\GraphQL\\Validators\\RevertPlaceCandidateValidator")

  createClassification(
    classification: CreateClassificationInput! @spread
  ): Classification @create @guard @canModel(ability: "create")
  updateClassification(
    id: ID!
    classification: UpdateClassificationInput! @spread
  ): Classification @update @guard @canFind(ability: "update", find: "id")
  deleteClassification(id: ID! @whereKey): Classification
    @delete
    @guard
    @canFind(ability: "delete", find: "id")
  createDepartment(department: CreateDepartmentInput! @spread): Department
    @create
    @guard
    @canModel(ability: "create")
  updateDepartment(
    id: ID!
    department: UpdateDepartmentInput! @spread
  ): Department @update @canFind(ability: "update", find: "id") @validator
  deleteDepartment(id: ID! @whereKey): Department
    @delete
    @guard
    @canFind(ability: "delete", find: "id")

  # SearchRequest mutations
  createPoolCandidateSearchRequest(
    poolCandidateSearchRequest: CreatePoolCandidateSearchRequestInput! @spread
  ): PoolCandidateSearchRequest @create @canModel(ability: "create")
  updatePoolCandidateSearchRequest(
    id: ID!
    poolCandidateSearchRequest: UpdatePoolCandidateSearchRequestInput! @spread
  ): PoolCandidateSearchRequest
    @update
    @guard
    @canFind(ability: "update", find: "id")
  deletePoolCandidateSearchRequest(
    id: ID! @whereKey
  ): PoolCandidateSearchRequest
    @delete
    @guard
    @canFind(ability: "delete", find: "id")

  createSkillFamily(skillFamily: CreateSkillFamilyInput! @spread): SkillFamily
    @create
    @guard
    @canModel(ability: "create")
  updateSkillFamily(
    id: ID!
    skillFamily: UpdateSkillFamilyInput! @spread
  ): SkillFamily @update @guard @canFind(ability: "update", find: "id")

  # skill mutations
  createSkill(skill: CreateSkillInput! @spread): Skill
    @create
    @guard
    @canModel(ability: "create")
  updateSkill(id: ID!, skill: UpdateSkillInput! @spread): Skill
    @update
    @guard
    @canFind(ability: "update", find: "id")
  deleteSkill(id: UUID! @whereKey): Skill
    @delete
    @validator(class: "App\\GraphQL\\Validators\\DeleteSkillValidator")
    @canModel(ability: "delete")

  createWorkExperience(
    userId: ID! @rename(attribute: "user_id")
    workExperience: WorkExperienceInput! @spread
  ): WorkExperience
    @create
    @canModel(ability: "create", injectArgs: true)
    @validator(
      class: "App\\GraphQL\\Validators\\CreateUpdateWorkExperienceValidator"
    )
  createPersonalExperience(
    userId: ID! @rename(attribute: "user_id")
    personalExperience: PersonalExperienceInput! @spread
  ): PersonalExperience @create @canModel(ability: "create", injectArgs: true)
  createCommunityExperience(
    userId: ID! @rename(attribute: "user_id")
    communityExperience: CommunityExperienceInput! @spread
  ): CommunityExperience @create @canModel(ability: "create", injectArgs: true)
  createEducationExperience(
    userId: ID! @rename(attribute: "user_id")
    educationExperience: EducationExperienceInput! @spread
  ): EducationExperience @create @canModel(ability: "create", injectArgs: true)
  createAwardExperience(
    userId: ID! @rename(attribute: "user_id")
    awardExperience: AwardExperienceInput! @spread
  ): AwardExperience @create @canModel(ability: "create", injectArgs: true)
  updateWorkExperience(
    id: ID!
    workExperience: WorkExperienceInput! @spread
  ): WorkExperience
    @update
    @guard
    @canFind(ability: "update", find: "id")
    @validator(
      class: "App\\GraphQL\\Validators\\CreateUpdateWorkExperienceValidator"
    )
  updatePersonalExperience(
    id: ID!
    personalExperience: PersonalExperienceInput! @spread
  ): PersonalExperience @update @guard @canFind(ability: "update", find: "id")
  updateCommunityExperience(
    id: ID!
    communityExperience: CommunityExperienceInput! @spread
  ): CommunityExperience @update @guard @canFind(ability: "update", find: "id")
  updateEducationExperience(
    id: ID!
    educationExperience: EducationExperienceInput! @spread
  ): EducationExperience @update @guard @canFind(ability: "update", find: "id")
  updateAwardExperience(
    id: ID!
    awardExperience: AwardExperienceInput! @spread
  ): AwardExperience @update @guard @canFind(ability: "update", find: "id")
  deleteWorkExperience(id: ID! @whereKey): WorkExperience
    @delete
    @guard
    @canFind(ability: "delete", find: "id")
  deletePersonalExperience(id: ID! @whereKey): PersonalExperience
    @delete
    @guard
    @canFind(ability: "delete", find: "id")
  deleteCommunityExperience(id: ID! @whereKey): CommunityExperience
    @delete
    @guard
    @canFind(ability: "delete", find: "id")
  deleteEducationExperience(id: ID! @whereKey): EducationExperience
    @delete
    @guard
    @canFind(ability: "delete", find: "id")
  deleteAwardExperience(id: ID! @whereKey): AwardExperience
    @delete
    @guard
    @canFind(ability: "delete", find: "id")

  # Pool mutations
  createPool(
    userId: ID! @rename(attribute: "user_id")
    teamId: ID! @rename(attribute: "team_id")
    communityId: ID! @rename(attribute: "community_id")
    pool: CreatePoolInput! @spread
  ): Pool @create @guard @canModel(ability: "create", injectArgs: true)
  duplicatePool(
    id: ID!
    teamId: ID! @rename(attribute: "team_id")
    pool: DuplicatePoolInput! @spread
  ): Pool @guard @canModel(ability: "duplicate", injectArgs: true)
  updatePool(id: ID!, pool: UpdatePoolInput! @spread): Pool
    @update
    @guard
    @canFind(ability: "updateDraft", find: "id")
  updatePublishedPool(id: ID!, pool: UpdatePublishedPoolInput! @spread): Pool
    @update
    @guard
    @canFind(ability: "updatePublished", find: "id")
  togglePoolUserBookmark(poolId: UUID! @rename(attribute: "pool_id")): Pool
    @guard
    @canFind(ability: "view", find: "pool_id", model: "Pool", injectArgs: true)

  createPoolSkill(poolSkill: CreatePoolSkillInput! @spread): PoolSkill
    @create
    @guard
    @canFind(
      ability: "updateDraft"
      find: "pool_id"
      model: "Pool"
      injectArgs: true
    )
  updatePoolSkill(id: ID!, poolSkill: UpdatePoolSkillInput! @spread): PoolSkill
    @update
    @guard
    @canFind(ability: "update", find: "id", model: "PoolSkill")
  deletePoolSkill(id: ID! @whereKey): PoolSkill
    @delete
    @guard
    @canFind(ability: "delete", find: "id", model: "PoolSkill")
  publishPool(id: ID!): Pool @guard @canFind(ability: "publish", find: "id")
  changePoolClosingDate(id: ID!, closingDate: DateTime!): Pool
    @guard
    @canFind(ability: "changePoolClosingDate", find: "id")
    @validator(
      class: "App\\GraphQL\\Validators\\ChangePoolClosingDateValidator"
    )
  closePool(
    id: ID!
    reason: String!
      @rename(attribute: "closing_reason")
      @rules(apply: ["required"])
  ): Pool @guard @canFind(ability: "closePool", find: "id")
  deletePool(id: ID! @whereKey): Pool
    @forceDelete(model: "Pool")
    @guard
    @canFind(ability: "deleteDraft", find: "id")
  archivePool(id: ID!): Pool
    @guard
    @canFind(ability: "archiveAndUnarchive", find: "id")
  unarchivePool(id: ID!): Pool
    @guard
    @canFind(ability: "archiveAndUnarchive", find: "id")

  # Application mutations
  changeApplicationSuspendedAt(id: ID!, isSuspended: Boolean!): PoolCandidate
    @guard
    @canFind(ability: "suspend", find: "id")
  createApplication(userId: ID!, poolId: ID!): PoolCandidate
    @canModel(ability: "createDraft")
  deleteApplication(id: ID!): PoolCandidate
    @guard
    @canFind(ability: "delete", find: "id", model: "PoolCandidate")
  submitApplication(id: ID!, signature: String!): PoolCandidate
    @guard
    @canFind(ability: "submit", find: "id")
  updateApplication(
    id: ID!
    application: UpdateApplicationInput! @spread
  ): PoolCandidate
    @update(model: "PoolCandidate")
    @guard
    @canFind(ability: "update", find: "id", model: "PoolCandidate")

  # Job poster template mutations
  createJobPosterTemplate(
    jobPosterTemplate: CreateJobPosterTemplateInput! @spread
  ): JobPosterTemplate @create @guard @canModel(ability: "create")
  updateJobPosterTemplate(
    jobPosterTemplate: UpdateJobPosterTemplateInput! @spread
  ): JobPosterTemplate @update @guard @canFind(ability: "update", find: "id")
  deleteJobPosterTemplate(id: UUID! @whereKey): JobPosterTemplate
    @delete
    @guard
    @canFind(ability: "delete", find: "id")

  # Work stream mutations
  createWorkStream(workStream: CreateWorkStreamInput! @spread): WorkStream
    @create
    @guard
    @canModel(ability: "create")
  updateWorkStream(
    id: UUID!
    workStream: UpdateWorkStreamInput! @spread
  ): WorkStream @update @guard @canFind(ability: "update", find: "id")

  # Teams mutations
  createTeam(team: CreateTeamInput! @spread): Team
    @create
    @canModel(ability: "create")
  updateTeam(id: UUID!, team: UpdateTeamInput! @spread): Team
    @update
    @canModel(ability: "update")
    @validator
  deleteTeam(id: UUID! @whereKey): Team
    @delete
    @guard
    @canFind(ability: "delete", find: "id")

  # Communities mutations
  createCommunity(community: CreateCommunityInput! @spread): Community
    @create
    @canModel(ability: "create")
    @validator
  updateCommunity(
    id: UUID!
    community: UpdateCommunityInput! @spread
  ): Community @update @canFind(ability: "update", find: "id") @validator

  # Talent nomination event mutations
  createTalentNominationEvent(
    talentNominationEvent: CreateTalentNominationEventInput! @spread
  ): TalentNominationEvent
    @create
    @guard
    @canModel(ability: "create", injectArgs: true)
  updateTalentNominationEvent(
    id: UUID!
    talentNominationEvent: UpdateTalentNominationEventInput! @spread
  ): TalentNominationEvent
    @update
    @guard
    @canFind(ability: "update", find: "id")

  #Talent nomination mutations
  createTalentNomination(
    talentNomination: CreateTalentNominationInput! @spread
  ): TalentNomination
    @create
    @inject(context: "user.id", name: "submitter_id")
    @guard
    @canModel(ability: "create")
  updateTalentNomination(
    id: UUID!
    talentNomination: UpdateTalentNominationInput! @spread
  ): TalentNomination @update @guard @canFind(ability: "update", find: "id")
  submitTalentNomination(id: UUID!): TalentNomination
    @guard
    @canFind(ability: "update", find: "id")

  # Notifications
  markNotificationAsRead(id: UUID!): Notification @guard # can only affect notifications belonging to the logged-in user
  markNotificationAsUnread(id: UUID!): Notification @guard
  deleteNotification(id: UUID!): Notification @guard
  markAllNotificationsAsRead: [Notification] @guard
  updateEnabledNotifications(
    enabledEmailNotifications: [NotificationFamily]
    enabledInAppNotifications: [NotificationFamily]
  ): User @guard @validator
  # UserSkill mutations
  createUserSkill(
    userId: UUID! @rename(attribute: "user_id")
    skillId: UUID! @rename(attribute: "skill_id")
    userSkill: CreateUserSkillInput @spread
  ): UserSkill @canModel(ability: "create", injectArgs: true)
  updateUserSkill(
    id: UUID!
    userSkill: UpdateUserSkillInput @spread
  ): UserSkill @update @canFind(ability: "update", find: "id")
  updateUserSkillRankings(
    userId: UUID!
    userSkillRanking: UpdateUserSkillRankingsInput!
  ): User @canFind(ability: "update", find: "userId")
  deleteUserSkill(id: UUID! @whereKey): UserSkill
    @canFind(ability: "delete", find: "id")
    @delete

  # Assessment mutations
  createAssessmentStep(
    poolId: UUID! @rename(attribute: "pool_id")
    assessmentStep: AssessmentStepInput @spread
  ): AssessmentStep
    @create
    @guard
    @canModel(ability: "create", injectArgs: true)
  updateAssessmentStep(
    id: UUID!
    assessmentStep: AssessmentStepInput @spread
  ): AssessmentStep @update @guard @canFind(ability: "update", find: "id")
  swapAssessmentStepOrder(stepIdA: UUID!, stepIdB: UUID!): [AssessmentStep]
    @guard
    @canFind(ability: "update", find: "stepIdA")
    @canFind(ability: "update", find: "stepIdB")
  createOrUpdateScreeningQuestionAssessmentStep(
    poolId: UUID!
    screeningQuestions: [SyncScreeningQuestionsInput]
    assessmentStep: ScreeningQuestionAssessmentStepInput
  ): Pool @guard @canFind(ability: "updateDraft", find: "poolId")
  deleteAssessmentStep(id: UUID! @whereKey): AssessmentStep
    @delete
    @guard
    @canFind(ability: "update", find: "id")
  createAssessmentResult(
    createAssessmentResult: CreateAssessmentResultInput! @spread
  ): AssessmentResult
    @create
    @guard
    @canModel(ability: "create", injectArgs: true)
  updateAssessmentResult(
    updateAssessmentResult: UpdateAssessmentResultInput! @spread
  ): AssessmentResult @update @guard @canFind(ability: "update", find: "id")
  deleteAssessmentResult(id: UUID! @whereKey): AssessmentResult
    @delete
    @canFind(ability: "update", find: "id")

  updateSitewideAnnouncement(
    sitewideAnnouncementInput: SitewideAnnouncementInput! @spread
  ): SitewideAnnouncement @guard

  createTrainingOpportunity(
    createTrainingOpportunity: CreateTrainingOpportunityInput! @spread
  ): TrainingOpportunity @create @guard @canModel(ability: "create")
  updateTrainingOpportunity(
    updateTrainingOpportunity: UpdateTrainingOpportunityInput! @spread
  ): TrainingOpportunity @update @guard @canModel(ability: "update")

  # CSV file downloads
  downloadPoolCandidatesCsv(
    ids: [UUID!]
    where: PoolCandidateSearchInput
    withROD: Boolean
  ): Boolean! @guard
  downloadUsersCsv(ids: [UUID!], where: UserFilterInput): Boolean! @guard

  # ZIP file downloads
  downloadApplicationsZip(ids: [UUID!]!): Boolean! @guard
  downloadPoolCandidatesZip(ids: [UUID!]!, anonymous: Boolean!): Boolean! @guard
  downloadUsersZip(ids: [UUID!]!, anonymous: Boolean!): Boolean! @guard

  # Downloads for single entity, returning file name if successful or null on error
  downloadUserDoc(id: UUID!, anonymous: Boolean!): String
    @guard
    @canFind(ability: "view", find: "id", model: "User")
  downloadPoolCandidateDoc(id: UUID!, anonymous: Boolean!): String
    @guard
    @canFind(ability: "view", find: "id", model: "PoolCandidate")
  downloadApplicationDoc(id: UUID!): String
    @guard
    @canFind(ability: "view", find: "id", model: "PoolCandidate")
}
