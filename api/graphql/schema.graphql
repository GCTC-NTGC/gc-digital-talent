"A date string with format `Y-m-d`, e.g. `2011-05-23`."
scalar Date @scalar(class: "Nuwave\\Lighthouse\\Schema\\Types\\Scalars\\Date")

"A datetime string with format `Y-m-d H:i:s`, e.g. `2018-05-23 13:43:32`."
scalar DateTime
  @scalar(class: "Nuwave\\Lighthouse\\Schema\\Types\\Scalars\\DateTime")

"A RFC 5321 compliant email."
scalar Email @scalar(class: "MLL\\GraphQLScalars\\Email")

"A phone number string, accepts any string"
scalar PhoneNumber

"A human readable ID"
scalar KeyString

"Arbitrary data encoded in JavaScript Object Notation. See https://www.json.org."
scalar JSON @scalar(class: "MLL\\GraphQLScalars\\JSON")

"128 bit universally unique identifier (UUID)"
scalar UUID @scalar(class: "UUID")

type LocalizedString {
  en: String
  fr: String
}

enum Language {
  EN @enum(value: "en")
  FR @enum(value: "fr")
}

type User {
  id: ID!
  sub: String
  createdDate: DateTime @rename(attribute: "created_at")
  updatedDate: DateTime @rename(attribute: "updated_at")

  # Personal info
  firstName: String @rename(attribute: "first_name")
  lastName: String @rename(attribute: "last_name")
  email: Email
  telephone: PhoneNumber
  preferredLang: Language @rename(attribute: "preferred_lang")
  preferredLanguageForInterview: Language
    @rename(attribute: "preferred_language_for_interview")
  preferredLanguageForExam: Language
    @rename(attribute: "preferred_language_for_exam")
  currentProvince: ProvinceOrTerritory @rename(attribute: "current_province")
  currentCity: String @rename(attribute: "current_city")
  citizenship: CitizenshipStatus
  armedForcesStatus: ArmedForcesStatus @rename(attribute: "armed_forces_status")

  # Language
  languageAbility: LanguageAbility
    @rename(attribute: "language_ability")
    @deprecated(
      reason: "deprecated in favour of relying on lookingFor<Language>"
    )
  lookingForEnglish: Boolean @rename(attribute: "looking_for_english")
  lookingForFrench: Boolean @rename(attribute: "looking_for_french")
  lookingForBilingual: Boolean @rename(attribute: "looking_for_bilingual")
  bilingualEvaluation: BilingualEvaluation
    @rename(attribute: "bilingual_evaluation")
  comprehensionLevel: EvaluatedLanguageAbility
    @rename(attribute: "comprehension_level")
  writtenLevel: EvaluatedLanguageAbility @rename(attribute: "written_level")
  verbalLevel: EvaluatedLanguageAbility @rename(attribute: "verbal_level")
  estimatedLanguageAbility: EstimatedLanguageAbility
    @rename(attribute: "estimated_language_ability")

  # Gov info
  isGovEmployee: Boolean @rename(attribute: "is_gov_employee")
  govEmployeeType: GovEmployeeType @rename(attribute: "gov_employee_type")
  currentClassification: Classification @belongsTo # Users current classification
  department: Department @belongsTo
  hasPriorityEntitlement: Boolean @rename(attribute: "has_priority_entitlement")
  priorityNumber: String @rename(attribute: "priority_number")

  # Employment equity
  isWoman: Boolean @rename(attribute: "is_woman")
  hasDisability: Boolean @rename(attribute: "has_disability")
  isIndigenous: Boolean
    @rename(attribute: "is_indigenous")
    @deprecated(reason: "replaced by indigenousCommunities")
  isVisibleMinority: Boolean @rename(attribute: "is_visible_minority")
  indigenousCommunities: [IndigenousCommunity]
    @rename(attribute: "indigenous_communities")
  indigenousDeclarationSignature: String
    @rename(attribute: "indigenous_declaration_signature")

  # Applicant info
  jobLookingStatus: JobLookingStatus
    @rename(attribute: "job_looking_status")
    @deprecated(reason: "Removing with applicantDashboard feature flag")
  hasDiploma: Boolean @rename(attribute: "has_diploma")
  locationPreferences: [WorkRegion] @rename(attribute: "location_preferences")
  locationExemptions: String @rename(attribute: "location_exemptions")
  acceptedOperationalRequirements: [OperationalRequirement]
    @rename(attribute: "accepted_operational_requirements")
  expectedSalary: [SalaryRange] @rename(attribute: "expected_salary")
  expectedClassifications: [Classification] @belongsToMany
  wouldAcceptTemporary: Boolean
    @rename(attribute: "would_accept_temporary")
    @deprecated(reason: "replaced with positionDuration")
  positionDuration: [PositionDuration] @rename(attribute: "position_duration")

  # Pool info
  poolCandidates: [PoolCandidate]
    @hasMany(scopes: ["authorizedToView"])
    @can(ability: "view", resolved: true) # PoolsCandidate objects associate the user with a pool
  # Experiences
  experiences: [Experience]
    @with(relation: "awardExperiences")
    @with(relation: "communityExperiences")
    @with(relation: "educationExperiences")
    @with(relation: "personalExperiences")
    @with(relation: "workExperiences") # All experiences that a user owns
  awardExperiences: [AwardExperience] @hasMany # Award experiences that a user owns
  communityExperiences: [CommunityExperience] @hasMany # Community experiences that a user owns
  educationExperiences: [EducationExperience] @hasMany # Education experiences that a user owns
  personalExperiences: [PersonalExperience] @hasMany # Personal experiences that a user owns
  workExperiences: [WorkExperience] @hasMany # Work experiences that a user owns
  # Skill Library
  userSkills: [UserSkill!] @hasMany
  # Pool Manager info
  pools: [Pool]
    @hasMany
    @can(ability: "view", resolved: true)
    @deprecated(
      reason: "Pools are now associated with a Team more than a single User. Use User.roles.team.pools instead."
    ) # Pools a user owns
  # Profile Status
  isProfileComplete: Boolean
  expectedGenericJobTitles: [GenericJobTitle] @belongsToMany
  priorityWeight: Int @rename(attribute: "priority_weight")
  # teams and roles
  roleAssignments: [RoleAssignment!] @hasMany

  # Notifications
  unreadNotifications: [Notification!]
    @rename(attribute: "unread_enriched_notifications")
  notifications: [Notification!] @rename(attribute: "enriched_notifications")
}

enum ProvinceOrTerritory {
  BRITISH_COLUMBIA
  ALBERTA
  SASKATCHEWAN
  MANITOBA
  ONTARIO
  QUEBEC
  NEW_BRUNSWICK
  NOVA_SCOTIA
  PRINCE_EDWARD_ISLAND
  NEWFOUNDLAND_AND_LABRADOR
  YUKON
  NORTHWEST_TERRITORIES
  NUNAVUT
}

enum BilingualEvaluation {
  COMPLETED_ENGLISH
  COMPLETED_FRENCH
  NOT_COMPLETED
}

enum EvaluatedLanguageAbility {
  X
  A
  B
  C
  E
  P
}

enum EstimatedLanguageAbility {
  BEGINNER
  INTERMEDIATE
  ADVANCED
}

enum JobLookingStatus {
  ACTIVELY_LOOKING
  OPEN_TO_OPPORTUNITIES
  INACTIVE
}

enum GovEmployeeType {
  STUDENT
  CASUAL
  TERM
  INDETERMINATE
}

enum CitizenshipStatus {
  CITIZEN
  PERMANENT_RESIDENT
  OTHER
}

enum ArmedForcesStatus {
  VETERAN
  MEMBER
  NON_CAF
}

enum PositionDuration {
  TEMPORARY
  PERMANENT
}

enum IndigenousCommunity {
  STATUS_FIRST_NATIONS
  NON_STATUS_FIRST_NATIONS
  INUIT
  METIS
  OTHER
  LEGACY_IS_INDIGENOUS
}

interface Notification {
  id: ID!
  readAt: DateTime @rename(attribute: "read_at")
  createdAt: DateTime @rename(attribute: "created_at")
  updatedAt: DateTime @rename(attribute: "updated_at")
}

type PoolCandidateStatusChangedNotification implements Notification {
  id: ID!
  readAt: DateTime @rename(attribute: "read_at")
  createdAt: DateTime @rename(attribute: "created_at")
  updatedAt: DateTime @rename(attribute: "updated_at")

  oldStatus: PoolCandidateStatus @rename(attribute: "old_status")
  newStatus: PoolCandidateStatus @rename(attribute: "new_status")
  poolId: ID @rename(attribute: "pool_id")
  poolName: LocalizedString @rename(attribute: "pool_name")
}

type UserPublicProfile {
  id: ID!
  email: Email
  firstName: String @rename(attribute: "first_name")
  lastName: String @rename(attribute: "last_name")
}

type ScreeningQuestion {
  id: ID!
  pool: Pool @belongsTo
  question: LocalizedString
  sortOrder: Int @rename(attribute: "sort_order")
  screeningQuestionResponses: [ScreeningQuestionResponse] @hasMany
}

type Pool {
  id: ID!
  owner: UserPublicProfile @belongsTo(relation: "user")
  team: Team @belongsTo @can(ability: "viewAny")
  name: LocalizedString
  classifications: [Classification] @belongsToMany
  operationalRequirements: [OperationalRequirement]
    @rename(attribute: "operational_requirements")
  poolCandidates: [PoolCandidate]
    @hasMany(relation: "publishedPoolCandidates")
    @can(ability: "view", resolved: true)
  keyTasks: LocalizedString @rename(attribute: "key_tasks")
  yourImpact: LocalizedString @rename(attribute: "your_impact")
  isRemote: Boolean @rename(attribute: "is_remote")
  location: LocalizedString @rename(attribute: "advertisement_location")
  securityClearance: SecurityStatus @rename(attribute: "security_clearance")
  language: PoolLanguage @rename(attribute: "advertisement_language")
  status: PoolStatus @rename(attribute: "status")
  essentialSkills: [Skill!] @belongsToMany
  nonessentialSkills: [Skill!] @belongsToMany
  stream: PoolStream
  processNumber: String @rename(attribute: "process_number")
  publishingGroup: PublishingGroup @rename(attribute: "publishing_group")
  createdDate: DateTime @rename(attribute: "created_at")
  updatedDate: DateTime @rename(attribute: "updated_at")
  screeningQuestions: [ScreeningQuestion]
    @hasMany
    @orderBy(column: "sort_order", direction: ASC)
  closingDate: DateTime @rename(attribute: "closing_date")
  publishedAt: DateTime @rename(attribute: "published_at")
}

enum PoolStream {
  BUSINESS_ADVISORY_SERVICES
  DATABASE_MANAGEMENT
  ENTERPRISE_ARCHITECTURE
  INFRASTRUCTURE_OPERATIONS
  PLANNING_AND_REPORTING
  PROJECT_PORTFOLIO_MANAGEMENT
  SECURITY
  SOFTWARE_SOLUTIONS
  INFORMATION_DATA_FUNCTIONS
}

enum PoolStatus {
  DRAFT
  PUBLISHED
  CLOSED
  ARCHIVED
}

enum PoolCandidateStatus {
  DRAFT
  DRAFT_EXPIRED
  NEW_APPLICATION
  APPLICATION_REVIEW
  SCREENED_IN
  SCREENED_OUT_APPLICATION
  UNDER_ASSESSMENT
  SCREENED_OUT_ASSESSMENT
  QUALIFIED_AVAILABLE
  QUALIFIED_UNAVAILABLE
  QUALIFIED_WITHDREW
  PLACED_CASUAL
  PLACED_TERM
  PLACED_INDETERMINATE
  EXPIRED
  REMOVED
}

enum SecurityStatus {
  RELIABILITY
  SECRET
  TOP_SECRET
}

enum PoolLanguage {
  ENGLISH
  FRENCH
  VARIOUS
  BILINGUAL_INTERMEDIATE
  BILINGUAL_ADVANCED
}

enum PublishingGroup {
  IAP
  IT_JOBS
  IT_JOBS_ONGOING
  EXECUTIVE_JOBS
  OTHER
}

enum ApplicationStep {
  WELCOME
  SELF_DECLARATION
  REVIEW_YOUR_PROFILE
  REVIEW_YOUR_RESUME
  EDUCATION_REQUIREMENTS
  SKILL_REQUIREMENTS
  SCREENING_QUESTIONS
  REVIEW_AND_SUBMIT
}

enum EducationRequirementOption {
  APPLIED_WORK
  EDUCATION
}

type ScreeningQuestionResponse {
  id: ID!
  answer: String
  screeningQuestion: ScreeningQuestion @belongsTo
  poolCandidate: PoolCandidate @belongsTo
}

type PoolCandidate {
  id: ID!
  pool: Pool! @belongsTo @can(ability: "view", resolved: true)
  user: User! @belongsTo(relation: "user")

  # cmoIdentifier can be an arbitrary string used to relate this candidate to an external database.
  cmoIdentifier: ID @rename(attribute: "cmo_identifier")
  # Expiry date for this candidate being in the pool.
  expiryDate: Date @rename(attribute: "expiry_date")

  status: PoolCandidateStatus @rename(attribute: "pool_candidate_status")
  statusWeight: Int @rename(attribute: "status_weight")
  notes: String
  archivedAt: DateTime @rename(attribute: "archived_at")
  submittedAt: DateTime @rename(attribute: "submitted_at")
  suspendedAt: DateTime @rename(attribute: "suspended_at")

  profileSnapshot: JSON @rename(attribute: "profile_snapshot")
  signature: String
  submittedSteps: [ApplicationStep!] @rename(attribute: "submitted_steps")
  screeningQuestionResponses: [ScreeningQuestionResponse] @hasMany
  educationRequirementOption: EducationRequirementOption
    @rename(attribute: "education_requirement_option") # associated experiences to fulfill this called educationRequirementExperiences
  educationRequirementExperiences: [Experience]  # collection of experiences associated with educationRequirementOption
    @with(relation: "educationRequirementAwardExperiences")
    @with(relation: "educationRequirementCommunityExperiences")
    @with(relation: "educationRequirementEducationExperiences")
    @with(relation: "educationRequirementPersonalExperiences")
    @with(relation: "educationRequirementWorkExperiences")
}

type PoolCandidateWithSkillCount {
  id: ID!
  poolCandidate: PoolCandidate! @self
  skillCount: Int @rename(attribute: "skill_count") # will always be null unless used with skillsAdditive or skillsIntersectional scope
}

enum LanguageAbility {
  ENGLISH
  FRENCH
  BILINGUAL
}

enum WorkRegion {
  TELEWORK
  NATIONAL_CAPITAL
  ATLANTIC
  QUEBEC
  ONTARIO
  PRAIRIE
  BRITISH_COLUMBIA
  NORTH
}

"""
e.g. Overtime as Required, Shift Work, Travel as Required, etc.
"""
enum OperationalRequirement {
  SHIFT_WORK
  ON_CALL
  TRAVEL
  TRANSPORT_EQUIPMENT
  DRIVERS_LICENSE
  OVERTIME_SCHEDULED
  OVERTIME_SHORT_NOTICE
  OVERTIME_OCCASIONAL
  OVERTIME_REGULAR
}

enum SalaryRange {
  _50_59K
  _60_69K
  _70_79K
  _80_89K
  _90_99K
  _100K_PLUS
}

type Classification {
  id: ID!
  name: LocalizedString
  group: String!
  level: Int!
  minSalary: Int @rename(attribute: "min_salary")
  maxSalary: Int @rename(attribute: "max_salary")
  genericJobTitles: [GenericJobTitle] @belongsToMany
}

enum GenericJobTitleKey {
  TECHNICIAN_IT01
  ANALYST_IT02
  TEAM_LEADER_IT03
  TECHNICAL_ADVISOR_IT03
  SENIOR_ADVISOR_IT04
  MANAGER_IT04
}

type GenericJobTitle {
  id: ID!
  key: GenericJobTitleKey!
  name: LocalizedString
  classification: Classification @belongsTo
}

type Department {
  id: ID!
  departmentNumber: Int! @rename(attribute: "department_number")
  name: LocalizedString!
  teams: [Team] @belongsToMany @can(ability: "viewAny")
}

type Team {
  id: ID!
  name: String! # represents a unique key for a team
  displayName: LocalizedString @rename(attribute: "display_name")
  description: LocalizedString
  departments: [Department] @belongsToMany
  contactEmail: Email @rename(attribute: "contact_email")
  pools: [Pool] @hasMany @can(ability: "view", resolved: true)
  roleAssignments: [RoleAssignment!]
    @hasMany
    @canOnParent(ability: "viewTeamMembers")
}

type Role {
  id: ID!
  name: String! # represents a unique key for a role
  displayName: LocalizedString @rename(attribute: "display_name")
  description: LocalizedString
  isTeamBased: Boolean @rename(attribute: "is_team_based")
  roleAssignments: [RoleAssignment!]
    @hasMany
    @can(ability: "viewAnyRoleAssignments", model: "Role")
}

# This model represents the polymorphic role_user table and allows querying the team relationship
type RoleAssignment {
  id: ID!
  role: Role @belongsTo
  team: Team @belongsTo
  user: UserPublicProfile @morphTo
}

enum PoolCandidateSearchStatus {
  NEW
  IN_PROGRESS
  WAITING
  DONE
}

# equity selections goes with the pool/applicant filters and not user model
type EquitySelections {
  isWoman: Boolean @rename(attribute: "is_woman")
  hasDisability: Boolean @rename(attribute: "has_disability")
  isIndigenous: Boolean @rename(attribute: "is_indigenous")
  isVisibleMinority: Boolean @rename(attribute: "is_visible_minority")
}

input EquitySelectionsInput {
  isWoman: Boolean @rename(attribute: "is_woman")
  hasDisability: Boolean @rename(attribute: "has_disability")
  isVisibleMinority: Boolean @rename(attribute: "is_visible_minority")
  isIndigenous: Boolean @rename(attribute: "is_indigenous")
}

type PoolCandidateFilter {
  id: ID!
  classifications: [Classification] @belongsToMany
  hasDiploma: Boolean @rename(attribute: "has_diploma")
  equity: EquitySelections
  languageAbility: LanguageAbility @rename(attribute: "language_ability")
  operationalRequirements: [OperationalRequirement]
    @rename(attribute: "operational_requirements")
  workRegions: [WorkRegion] @rename(attribute: "work_regions")
  pools: [Pool] @belongsToMany @can(ability: "view", resolved: true)
}

# ApplicantFilter only includes the fields which Talent Seekers can use to search for candidates.
type ApplicantFilter {
  id: ID!
  hasDiploma: Boolean @rename(attribute: "has_diploma")
  equity: EquitySelections
  languageAbility: LanguageAbility @rename(attribute: "language_ability")
  operationalRequirements: [OperationalRequirement]
    @rename(attribute: "operational_requirements")
  locationPreferences: [WorkRegion] @rename(attribute: "location_preferences")
  wouldAcceptTemporary: Boolean
    @rename(attribute: "would_accept_temporary")
    @deprecated(reason: "replaced with positionDuration")
  positionDuration: [PositionDuration] @rename(attribute: "position_duration")
  expectedClassifications: [Classification]  # Filters applicants based on the classifications they've expressed interest in.
    @belongsToMany(relation: "classifications")
  skills: [Skill] @belongsToMany
  # request creation connects to qualifiedClassifications
  qualifiedClassifications: [Classification] @belongsToMany # Filters applicants based on the classifications pools they've qualified in.
  qualifiedStreams: [PoolStream] @rename(attribute: "qualified_streams") # Filters applicants based on the streams of the pools they've qualified in.
  pools: [Pool] @belongsToMany @can(ability: "view", resolved: true)
}

type PoolCandidateSearchRequest {
  id: ID!
  fullName: String @rename(attribute: "full_name")
  email: Email
  department: Department @belongsTo
  jobTitle: String @rename(attribute: "job_title")
  additionalComments: String @rename(attribute: "additional_comments")
  requestedDate: DateTime @rename(attribute: "created_at")
  status: PoolCandidateSearchStatus @rename(attribute: "request_status")
  statusChangedAt: DateTime @rename(attribute: "request_status_changed_at")
  adminNotes: String @rename(attribute: "admin_notes")
  poolCandidateFilter: PoolCandidateFilter @belongsTo
  applicantFilter: ApplicantFilter @belongsTo
  wasEmpty: Boolean @rename(attribute: "was_empty")
}

enum SkillCategory {
  TECHNICAL
  BEHAVIOURAL
}

type SkillFamily {
  id: ID!
  key: KeyString!
  name: LocalizedString
  description: LocalizedString
  skills: [Skill!] @belongsToMany
  category: SkillCategory!
}

type Skill {
  id: ID!
  key: KeyString!
  name: LocalizedString!
  description: LocalizedString
  keywords: SkillKeywords
  families: [SkillFamily!] @belongsToMany

  # Experiences
  experiences: [Experience!]
  awardExperiences: [AwardExperience!] @hasMany
  communityExperiences: [CommunityExperience!] @hasMany
  educationExperiences: [EducationExperience!] @hasMany
  personalExperiences: [PersonalExperience!] @hasMany
  workExperiences: [WorkExperience!] @hasMany
  # ExperienceSkillRecord is the pivot data and may only be queried when Skill is nested in an Experience (eg. experience->skill->experienceSkillRecord). Querying for it otherwise will just return null.
  experienceSkillRecord: ExperienceSkillRecord
    @rename(attribute: "experience_skill")
}

type UserSkill {
  id: ID!
  user: User! @belongsTo @can(ability: "view", resolved: true)
  skill: Skill! @belongsTo
}

type SkillKeywords {
  en: [String!]
  fr: [String!]
}

enum AwardedTo {
  ME
  MY_TEAM
  MY_PROJECT
  MY_ORGANIZATION
}
enum AwardedScope {
  INTERNATIONAL
  NATIONAL
  PROVINCIAL
  LOCAL
  COMMUNITY
  ORGANIZATIONAL
  SUB_ORGANIZATIONAL
}

enum EducationType {
  DIPLOMA
  BACHELORS_DEGREE
  MASTERS_DEGREE
  PHD
  POST_DOCTORAL_FELLOWSHIP
  ONLINE_COURSE
  CERTIFICATION
  OTHER
}
enum EducationStatus {
  SUCCESS_CREDENTIAL
  SUCCESS_NO_CREDENTIAL
  IN_PROGRESS
  AUDITED
  DID_NOT_COMPLETE
}

interface Experience {
  id: ID!
  user: User! @belongsTo(relation: "user")
  details: String
  skills: [Skill!] @morphToMany
  # ExperienceSkillRecord is the pivot data and may only be queried when Experience is nested in a Skill (eg. skill->experiences->experienceSkillRecord). Querying for it otherwise will just return null.
  experienceSkillRecord: ExperienceSkillRecord
    @rename(attribute: "experience_skill")
}

type WorkExperience implements Experience {
  id: ID!
  user: User! @belongsTo(relation: "user")
  role: String
  organization: String
  division: String
  startDate: Date @rename(attribute: "start_date")
  endDate: Date @rename(attribute: "end_date")
  details: String
  skills: [Skill!] @morphToMany
  # ExperienceSkillRecord is the pivot data and may only be queried when Experience is nested in a Skill (eg. skill->experiences->experienceSkillRecord). Querying for it otherwise will just return null.
  experienceSkillRecord: ExperienceSkillRecord
    @rename(attribute: "experience_skill")
}
type PersonalExperience implements Experience {
  id: ID!
  user: User! @belongsTo(relation: "user")
  title: String
  description: String
  startDate: Date @rename(attribute: "start_date")
  endDate: Date @rename(attribute: "end_date")
  details: String
  skills: [Skill!] @morphToMany
  # ExperienceSkillRecord is the pivot data and may only be queried when Experience is nested in a Skill (eg. skill->experiences->experienceSkillRecord). Querying for it otherwise will just return null.
  experienceSkillRecord: ExperienceSkillRecord
    @rename(attribute: "experience_skill")
}
type CommunityExperience implements Experience {
  id: ID!
  user: User! @belongsTo(relation: "user")
  title: String
  organization: String
  project: String
  startDate: Date @rename(attribute: "start_date")
  endDate: Date @rename(attribute: "end_date")
  details: String
  skills: [Skill!] @morphToMany
  # ExperienceSkillRecord is the pivot data and must be queried through a nested mutation (eg. experience->skill->experienceSkillRecord) querying for it directly will just return null
  experienceSkillRecord: ExperienceSkillRecord
    @rename(attribute: "experience_skill")
}
type EducationExperience implements Experience {
  id: ID!
  user: User! @belongsTo(relation: "user")
  institution: String
  areaOfStudy: String @rename(attribute: "area_of_study")
  thesisTitle: String @rename(attribute: "thesis_title")
  startDate: Date @rename(attribute: "start_date")
  endDate: Date @rename(attribute: "end_date")
  type: EducationType
  status: EducationStatus
  details: String
  skills: [Skill!] @morphToMany
  # ExperienceSkillRecord is the pivot data and may only be queried when Experience is nested in a Skill (eg. skill->experiences->experienceSkillRecord). Querying for it otherwise will just return null.
  experienceSkillRecord: ExperienceSkillRecord
    @rename(attribute: "experience_skill")
}
type AwardExperience implements Experience {
  id: ID!
  user: User! @belongsTo(relation: "user")
  title: String
  issuedBy: String @rename(attribute: "issued_by")
  awardedDate: Date @rename(attribute: "awarded_date")
  awardedTo: AwardedTo @rename(attribute: "awarded_to")
  awardedScope: AwardedScope @rename(attribute: "awarded_scope")
  details: String
  skills: [Skill!] @morphToMany
  # ExperienceSkillRecord is the pivot data and may only be queried when Experience is nested in a Skill (eg. skill->experiences->experienceSkillRecord). Querying for it otherwise will just return null.
  experienceSkillRecord: ExperienceSkillRecord
    @rename(attribute: "experience_skill")
}

type ExperienceSkillRecord {
  details: String
}

input ClassificationFilterInput {
  group: String!
  level: Int!
}

input KeyFilterInput {
  key: KeyString!
}

input IdInput {
  id: ID!
}

enum CandidateExpiryFilter {
  ACTIVE
  EXPIRED
  ALL
}

enum CandidateSuspendedFilter {
  ACTIVE
  SUSPENDED
  ALL
}

input UserPoolFilterInput {
  poolId: ID!
  expiryStatus: CandidateExpiryFilter = ACTIVE
  statuses: [PoolCandidateStatus!]
  suspendedStatus: CandidateSuspendedFilter = ACTIVE
}

input UserFilterInput {
  applicantFilter: ApplicantFilterInput @spread
  poolFilters: [UserPoolFilterInput] @scope(name: "poolFilters")
  jobLookingStatus: [JobLookingStatus]
  isProfileComplete: Boolean @scope
  isGovEmployee: Boolean @scope
  telephone: String @scope
  email: String @scope
  name: String @scope
  generalSearch: String @scope
}

# Changes to this input will require some manual updates to api/app/GraphQL/Queries/CountPoolCandidatesByPool.php since it doesn't use the directives for automatic resolution
input ApplicantFilterInput {
  equity: EquitySelectionsInput @scope
  expectedClassifications: [ClassificationFilterInput]  # Filters applicants based on the classifications they've expressed interest in.
    @scope(name: "expectedClassifications")
  hasDiploma: Boolean @scope
  languageAbility: LanguageAbility @scope
  locationPreferences: [WorkRegion] @scope
  operationalRequirements: [OperationalRequirement] @scope
  positionDuration: [PositionDuration] @scope
  # This field is [IdInput] instead of [ID] so that the output of an ApplicantFilter query can be used directly.
  pools: [IdInput] @scope(name: "availableInPools") @pluck(key: "id")
  skills: [IdInput] @scope(name: "skillsAdditive") @pluck(key: "id") # main one to correspond with ApplicantFilter.php
  skillsIntersectional: [IdInput] @scope @pluck(key: "id") # AND filtering skills as opposed to OR
  qualifiedClassifications: [ClassificationFilterInput]
    @scope(name: "qualifiedClassifications") # Filters applicants based on the classification of pools they are currently qualified and available in.
  qualifiedStreams: [PoolStream] @scope(name: "qualifiedStreams") # Filters applicants based on the stream of pools they are currently qualified and available in.
}

input PoolCandidateSearchInput {
  applicantFilter: ApplicantFilterInput @spread
  email: String @scope
  generalSearch: String @scope
  name: String @scope
  notes: String @scope
  priorityWeight: [Int] @scope(name: "priorityWeight")
  poolCandidateStatus: [PoolCandidateStatus]
    @scope(name: "poolCandidateStatuses")
  expiryStatus: CandidateExpiryFilter @scope(name: "expiryStatus")
  suspendedStatus: CandidateSuspendedFilter @scope(name: "suspendedStatus")
}

input PoolCandidateSearchRequestInput {
  status: [PoolCandidateSearchStatus] @scope(name: "searchRequestStatus")
  departments: [ID] @scope
  classifications: [ID] @scope
  streams: [PoolStream] @scope
  fullName: String @scope
  email: String @scope
  jobTitle: String @scope
  additionalComments: String @scope
  adminNotes: String @scope
  generalSearch: String @scope
}

type CandidateSearchPoolResult {
  pool: Pool! @can(ability: "view", resolved: true)
  candidateCount: Int! @rename(attribute: "candidate_count")
}

type Query {
  me: User @auth
  user(id: UUID! @eq): User @find @guard @can(ability: "view", query: true)
  users: [User]! @all @guard @can(ability: "viewAny")
  usersPaginated(
    where: UserFilterInput
    orderBy: [OrderByClause!] @orderBy
  ): [User]!
    @orderBy(column: "created_at", direction: DESC)
    @paginate(defaultCount: 10, maxCount: 1000)
    @guard
    @can(ability: "viewAny")
  applicant(id: UUID! @eq): User
    @find(model: "User")
    @guard
    @can(ability: "view", query: true, model: "User")
    @deprecated(reason: "Removing in favour of user query")
  applicants(includeIds: [ID]! @in(key: "id")): [User]!
    @all(model: "User")
    @guard
    @can(ability: "viewAny", model: "User")
    @deprecated(reason: "Removing in favour of users query")
  # countApplicants returns the number of candidates matching its filters, and requires no special permissions.
  countApplicants(where: ApplicantFilterInput): Int! @count(model: "User")
  pool(id: UUID! @eq): Pool @find @can(ability: "view", query: true)
  pools: [Pool]! @all @can(ability: "viewAny", model: "Pool")
  publishedPools(
    closingAfter: DateTime @where(key: "closing_date", operator: ">")
    publishingGroup: PublishingGroup
      @where(key: "publishing_group", operator: "=")
  ): [Pool!]!
    @all(scopes: ["wasPublished"])
    @can(ability: "viewAnyPublished", model: "Pool")
  poolByKey(key: String! @eq): Pool @find @can(ability: "view", query: true)
  pools: [Pool]!
    @all(scopes: ["authorizedToView"])
    @can(ability: "view", resolved: true)
  poolCandidate(id: UUID! @eq): PoolCandidate
    @find
    @guard
    @can(ability: "view", query: true)
  poolCandidates(includeIds: [ID] @in(key: "id")): [PoolCandidate]!
    @all(scopes: ["notDraft"])
    @guard
    @can(ability: "view", resolved: true)
  poolCandidatesPaginated(
    where: PoolCandidateSearchInput
    orderBy: _
      @orderBy(
        relations: [
          {
            relation: "user"
            columns: [
              "priority_weight"
              "job_looking_status"
              "first_name"
              "email"
              "preferred_lang"
              "preferred_language_for_interview"
              "preferred_language_for_exam"
              "current_city"
            ]
          }
        ]
      )
  ): [PoolCandidateWithSkillCount]!
    @paginate(
      defaultCount: 10
      maxCount: 1000
      scopes: ["notDraft", "withSkillCount"]
      model: "App\\Models\\PoolCandidate"
    )
    @guard
    @can(ability: "view", resolved: true, model: "App\\Models\\PoolCandidate")
  # This query lives at api/app/GraphQL/Queries/CountPoolCandidatesByPool.php.
  # Returns the number of candidates by filtering their parent applicant, grouped by pool.
  countPoolCandidatesByPool(
    where: ApplicantFilterInput
  ): [CandidateSearchPoolResult!]!
  classification(id: UUID! @eq): Classification @find @can(ability: "view")
  classifications: [Classification]! @all @can(ability: "viewAny")
  department(id: UUID! @eq): Department @find @can(ability: "view")
  departments: [Department]! @all @can(ability: "viewAny")
  poolCandidateFilter(id: UUID! @eq): PoolCandidateFilter
    @find
    @guard
    @can(ability: "viewAny", model: "PoolCandidateSearchRequest")
    @deprecated(
      reason: "This should only be queried as part of a PoolCandidateSearchRequest."
    )
  poolCandidateFilters: [PoolCandidateFilter]!
    @all
    @guard
    @can(ability: "viewAny", model: "PoolCandidateSearchRequest")
    @throttle(name: "graphql")
    @deprecated(
      reason: "This should only be queried as part of a PoolCandidateSearchRequest."
    )
  applicantFilter(id: ID! @eq): ApplicantFilter
    @find
    @guard
    @can(ability: "viewAny", model: "PoolCandidateSearchRequest")
    @deprecated(
      reason: "This should only be queried as part of a PoolCandidateSearchRequest."
    )
  applicantFilters: [ApplicantFilter]!
    @all
    @guard
    @can(ability: "viewAny", model: "PoolCandidateSearchRequest")
    @throttle(name: "graphql")
    @deprecated(
      reason: "This should only be queried as part of a PoolCandidateSearchRequest."
    )
  poolCandidateSearchRequest(id: ID! @eq): PoolCandidateSearchRequest
    @find
    @guard
    @can(ability: "view", query: true)
  poolCandidateSearchRequests(limit: Int @limit): [PoolCandidateSearchRequest]!
    @all
    @guard
    @can(ability: "viewAny")
    @orderBy(column: "created_at", direction: DESC)
  latestPoolCandidateSearchRequests(
    limit: Int @limit
  ): [PoolCandidateSearchRequest]!
    @all
    @orderBy(column: "created_at", direction: DESC)
    @guard
    @can(ability: "viewAny")
    @deprecated(
      reason: "Use poolCandidateSearchRequests instead, with a specified limit"
    )
  poolCandidateSearchRequestsPaginated(
    where: PoolCandidateSearchRequestInput
    orderBy: [OrderByClause!] @orderBy
  ): [PoolCandidateSearchRequest]!
    @orderBy(column: "created_at", direction: DESC)
    @paginate(defaultCount: 10, maxCount: 500)
    @guard
    @can(ability: "viewAny")
  skillFamily(id: UUID! @eq): SkillFamily @find @can(ability: "view")
  skillFamilies: [SkillFamily]! @all @can(ability: "viewAny")
  skill(id: UUID! @eq): Skill @find @can(ability: "view")
  skills: [Skill]! @all @can(ability: "viewAny")
  genericJobTitle(id: UUID! @eq): GenericJobTitle @find @can(ability: "view")
  genericJobTitles: [GenericJobTitle]! @all @can(ability: "viewAny")
  team(id: UUID! @eq): Team @find @can(ability: "view", query: true)
  teams: [Team]! @all @can(ability: "viewAny")
  roles: [Role]! @all @can(ability: "viewAny")
}

input ClassificationBelongsTo {
  connect: ID
  disconnect: Boolean
}
input PoolsHasMany {
  create: [CreatePoolInput]
}
"""
When creating a User, name is required.
"""
input CreateUserInput {
  sub: String
    @rules(
      apply: ["sometimes", "unique:users,sub"]
      messages: [{ rule: "unique", message: "CreateUserSubInUse" }]
    )

  # Personal info
  firstName: String! @rename(attribute: "first_name")
  lastName: String! @rename(attribute: "last_name")
  email: Email
    @lowerCase
    @rules(
      apply: ["sometimes", "nullable", "unique:users,email"]
      messages: [{ rule: "unique", message: "CreateUserEmailInUse" }]
    )
  telephone: PhoneNumber
  preferredLang: Language @rename(attribute: "preferred_lang")
  preferredLanguageForInterview: Language
    @rename(attribute: "preferred_language_for_interview")
  preferredLanguageForExam: Language
    @rename(attribute: "preferred_language_for_exam")
  currentProvince: ProvinceOrTerritory @rename(attribute: "current_province")
  currentCity: String @rename(attribute: "current_city")
  citizenship: CitizenshipStatus
  armedForcesStatus: ArmedForcesStatus @rename(attribute: "armed_forces_status")

  # Language
  lookingForEnglish: Boolean @rename(attribute: "looking_for_english")
  lookingForFrench: Boolean @rename(attribute: "looking_for_french")
  lookingForBilingual: Boolean @rename(attribute: "looking_for_bilingual")
  bilingualEvaluation: BilingualEvaluation
    @rename(attribute: "bilingual_evaluation")
  comprehensionLevel: EvaluatedLanguageAbility
    @rename(attribute: "comprehension_level")
  writtenLevel: EvaluatedLanguageAbility @rename(attribute: "written_level")
  verbalLevel: EvaluatedLanguageAbility @rename(attribute: "verbal_level")
  estimatedLanguageAbility: EstimatedLanguageAbility
    @rename(attribute: "estimated_language_ability")

  # Gov info
  isGovEmployee: Boolean @rename(attribute: "is_gov_employee")
  govEmployeeType: GovEmployeeType @rename(attribute: "gov_employee_type")
  currentClassification: ClassificationBelongsTo
  department: DepartmentBelongsTo
  hasPriorityEntitlement: Boolean @rename(attribute: "has_priority_entitlement")
  priorityNumber: String @rename(attribute: "priority_number")

  # Employment equity
  isWoman: Boolean @rename(attribute: "is_woman")
  hasDisability: Boolean @rename(attribute: "has_disability")
  isVisibleMinority: Boolean @rename(attribute: "is_visible_minority")
  indigenousCommunities: [IndigenousCommunity]
    @rename(attribute: "indigenous_communities")
  indigenousDeclarationSignature: String
    @rename(attribute: "indigenous_declaration_signature")

  # Applicant info
  jobLookingStatus: JobLookingStatus @rename(attribute: "job_looking_status")
  hasDiploma: Boolean @rename(attribute: "has_diploma")
  locationPreferences: [WorkRegion] @rename(attribute: "location_preferences")
  locationExemptions: String @rename(attribute: "location_exemptions")
  acceptedOperationalRequirements: [OperationalRequirement]
    @rename(attribute: "accepted_operational_requirements")
  expectedSalary: [SalaryRange] @rename(attribute: "expected_salary")
  expectedClassifications: ClassificationBelongsToMany
  expectedGenericJobTitles: GenericJobTitleBelongsToMany
  positionDuration: [PositionDuration] @rename(attribute: "position_duration")

  # Experiences
  workExperiences: WorkExperienceHasMany
  personalExperiences: PersonalExperienceHasMany
  communityExperiences: CommunityExperienceHasMany
  educationExperiences: EducationExperienceHasMany
  awardExperiences: AwardExperienceHasMany
}
"""
When updating a User, all fields are optional
"""
input UpdateUserAsAdminInput
  @validator(class: "App\\GraphQL\\Validators\\UpdateUserInputValidator") {
  id: ID
  sub: String

  # Personal info
  email: Email @lowerCase
  firstName: String @rename(attribute: "first_name")
  lastName: String @rename(attribute: "last_name")
  telephone: PhoneNumber
  preferredLang: Language @rename(attribute: "preferred_lang")
  preferredLanguageForInterview: Language
    @rename(attribute: "preferred_language_for_interview")
  preferredLanguageForExam: Language
    @rename(attribute: "preferred_language_for_exam")
  currentProvince: ProvinceOrTerritory @rename(attribute: "current_province")
  currentCity: String @rename(attribute: "current_city")
  citizenship: CitizenshipStatus
  armedForcesStatus: ArmedForcesStatus @rename(attribute: "armed_forces_status")

  # Language
  lookingForEnglish: Boolean @rename(attribute: "looking_for_english")
  lookingForFrench: Boolean @rename(attribute: "looking_for_french")
  lookingForBilingual: Boolean @rename(attribute: "looking_for_bilingual")
  bilingualEvaluation: BilingualEvaluation
    @rename(attribute: "bilingual_evaluation")
  comprehensionLevel: EvaluatedLanguageAbility
    @rename(attribute: "comprehension_level")
  writtenLevel: EvaluatedLanguageAbility @rename(attribute: "written_level")
  verbalLevel: EvaluatedLanguageAbility @rename(attribute: "verbal_level")
  estimatedLanguageAbility: EstimatedLanguageAbility
    @rename(attribute: "estimated_language_ability")

  # Gov info
  isGovEmployee: Boolean @rename(attribute: "is_gov_employee")
  govEmployeeType: GovEmployeeType @rename(attribute: "gov_employee_type")
  currentClassification: ClassificationBelongsTo
  department: DepartmentBelongsTo
  hasPriorityEntitlement: Boolean @rename(attribute: "has_priority_entitlement")
  priorityNumber: String @rename(attribute: "priority_number")

  # Employment equity
  isWoman: Boolean @rename(attribute: "is_woman")
  hasDisability: Boolean @rename(attribute: "has_disability")
  isVisibleMinority: Boolean @rename(attribute: "is_visible_minority")
  indigenousCommunities: [IndigenousCommunity]
    @rename(attribute: "indigenous_communities")
  indigenousDeclarationSignature: String
    @rename(attribute: "indigenous_declaration_signature")

  # Applicant info
  jobLookingStatus: JobLookingStatus @rename(attribute: "job_looking_status")

  hasDiploma: Boolean @rename(attribute: "has_diploma")
  locationPreferences: [WorkRegion] @rename(attribute: "location_preferences")
  locationExemptions: String @rename(attribute: "location_exemptions")
  acceptedOperationalRequirements: [OperationalRequirement]
    @rename(attribute: "accepted_operational_requirements")
  expectedSalary: [SalaryRange] @rename(attribute: "expected_salary")
  expectedClassifications: ClassificationBelongsToMany
  expectedGenericJobTitles: GenericJobTitleBelongsToMany
  positionDuration: [PositionDuration] @rename(attribute: "position_duration")

  # Experiences
  workExperiences: WorkExperienceHasMany
  personalExperiences: PersonalExperienceHasMany
  communityExperiences: CommunityExperienceHasMany
  educationExperiences: EducationExperienceHasMany
  awardExperiences: AwardExperienceHasMany

  roleAssignmentsInput: RoleAssignmentHasMany
}

input UpdateUserAsUserInput
  @validator(class: "App\\GraphQL\\Validators\\UpdateUserInputValidator") {
  id: ID
  # Personal info
  email: Email @lowerCase
  firstName: String @rename(attribute: "first_name")
  lastName: String @rename(attribute: "last_name")
  telephone: PhoneNumber
  preferredLang: Language @rename(attribute: "preferred_lang")
  preferredLanguageForInterview: Language
    @rename(attribute: "preferred_language_for_interview")
  preferredLanguageForExam: Language
    @rename(attribute: "preferred_language_for_exam")
  currentProvince: ProvinceOrTerritory @rename(attribute: "current_province")
  currentCity: String @rename(attribute: "current_city")
  citizenship: CitizenshipStatus
  armedForcesStatus: ArmedForcesStatus @rename(attribute: "armed_forces_status")

  # Language
  lookingForEnglish: Boolean @rename(attribute: "looking_for_english")
  lookingForFrench: Boolean @rename(attribute: "looking_for_french")
  lookingForBilingual: Boolean @rename(attribute: "looking_for_bilingual")
  bilingualEvaluation: BilingualEvaluation
    @rename(attribute: "bilingual_evaluation")
  comprehensionLevel: EvaluatedLanguageAbility
    @rename(attribute: "comprehension_level")
  writtenLevel: EvaluatedLanguageAbility @rename(attribute: "written_level")
  verbalLevel: EvaluatedLanguageAbility @rename(attribute: "verbal_level")
  estimatedLanguageAbility: EstimatedLanguageAbility
    @rename(attribute: "estimated_language_ability")

  # Gov info
  isGovEmployee: Boolean @rename(attribute: "is_gov_employee")
  govEmployeeType: GovEmployeeType @rename(attribute: "gov_employee_type")
  currentClassification: ClassificationBelongsTo
  department: DepartmentBelongsTo
  hasPriorityEntitlement: Boolean @rename(attribute: "has_priority_entitlement")
  priorityNumber: String @rename(attribute: "priority_number")

  # Employment equity
  isWoman: Boolean @rename(attribute: "is_woman")
  hasDisability: Boolean @rename(attribute: "has_disability")
  isVisibleMinority: Boolean @rename(attribute: "is_visible_minority")
  indigenousCommunities: [IndigenousCommunity]
    @rename(attribute: "indigenous_communities")
  indigenousDeclarationSignature: String
    @rename(attribute: "indigenous_declaration_signature")

  # Applicant info
  jobLookingStatus: JobLookingStatus @rename(attribute: "job_looking_status")

  hasDiploma: Boolean @rename(attribute: "has_diploma")
  locationPreferences: [WorkRegion] @rename(attribute: "location_preferences")
  locationExemptions: String @rename(attribute: "location_exemptions")
  acceptedOperationalRequirements: [OperationalRequirement]
    @rename(attribute: "accepted_operational_requirements")
  expectedSalary: [SalaryRange] @rename(attribute: "expected_salary")
  expectedClassifications: ClassificationBelongsToMany
  expectedGenericJobTitles: GenericJobTitleBelongsToMany
  positionDuration: [PositionDuration] @rename(attribute: "position_duration")

  # Experiences
  workExperiences: WorkExperienceHasMany
  personalExperiences: PersonalExperienceHasMany
  communityExperiences: CommunityExperienceHasMany
  educationExperiences: EducationExperienceHasMany
  awardExperiences: AwardExperienceHasMany
}

input LocalizedStringInput {
  en: String
  fr: String
}

input UserBelongsTo {
  connect: ID
}

input PoolBelongsTo {
  connect: ID!
}

input TeamBelongsTo {
  connect: ID!
}

input CreateClassificationInput {
  name: LocalizedStringInput
  group: String!
  level: Int!
  minSalary: Int @rename(attribute: "min_salary")
  maxSalary: Int @rename(attribute: "max_salary")
}

input ClassificationBelongsToMany {
  sync: [ID!]
}

input CreatePoolCandidateAsAdminInput {
  pool: PoolBelongsTo!
  user: UserBelongsTo!
  cmoIdentifier: ID @rename(attribute: "cmo_identifier")
  expiryDate: Date @rename(attribute: "expiry_date")
  status: PoolCandidateStatus = NEW_APPLICATION
    @rename(attribute: "pool_candidate_status")
  notes: String
}

input UpdateClassificationInput {
  name: LocalizedStringInput
  group: String
  minSalary: Int @rename(attribute: "min_salary")
  maxSalary: Int @rename(attribute: "max_salary")
}

input UpdatePoolCandidateAsAdminInput {
  cmoIdentifier: ID @rename(attribute: "cmo_identifier")
  expiryDate: Date @rename(attribute: "expiry_date")
  status: PoolCandidateStatus @rename(attribute: "pool_candidate_status")
  notes: String
}

input CreateDepartmentInput {
  departmentNumber: Int!
    @rename(attribute: "department_number")
    @rules(
      apply: ["unique:departments,department_number"]
      messages: [{ rule: "unique", message: "DepartmentNumberInUse" }]
    )
  name: LocalizedStringInput
}

input UpdateDepartmentInput {
  departmentNumber: Int @rename(attribute: "department_number")
  name: LocalizedStringInput
}

input PoolBelongsToMany {
  sync: [ID!]
}

input DepartmentBelongsTo {
  connect: ID
  disconnect: Boolean
}

input DepartmentBelongsToMany {
  sync: [ID!]
}

input CreateTeamInput {
  name: String!
  displayName: LocalizedStringInput @rename(attribute: "display_name")
  description: LocalizedStringInput
  departments: DepartmentBelongsToMany
  contactEmail: Email @rename(attribute: "contact_email")
}

input UpdateTeamInput {
  name: String
  displayName: LocalizedStringInput @rename(attribute: "display_name")
  description: LocalizedStringInput
  departments: DepartmentBelongsToMany
  contactEmail: Email @rename(attribute: "contact_email")
}

input CreateApplicantFilterInput {
  hasDiploma: Boolean @rename(attribute: "has_diploma")
  equity: EquitySelectionsInput @spread
  languageAbility: LanguageAbility @rename(attribute: "language_ability")
  operationalRequirements: [OperationalRequirement]
    @rename(attribute: "operational_requirements")
  locationPreferences: [WorkRegion] @rename(attribute: "location_preferences")
  positionDuration: [PositionDuration] @rename(attribute: "position_duration")
  expectedClassifications: ClassificationBelongsToMany
    @rename(attribute: "classifications")
  skills: SkillBelongsToMany
  pools: PoolBelongsToMany
  citizenship: CitizenshipStatus
  armedForcesStatus: ArmedForcesStatus @rename(attribute: "armed_forces_status")
  qualifiedClassifications: ClassificationBelongsToMany
  qualifiedStreams: [PoolStream] @rename(attribute: "qualified_streams")
}

input ApplicantFilterBelongsTo {
  create: CreateApplicantFilterInput!
}

input CreatePoolCandidateSearchRequestInput {
  fullName: String! @rename(attribute: "full_name")
  email: Email!
  department: DepartmentBelongsTo!
  jobTitle: String! @rename(attribute: "job_title")
  additionalComments: String @rename(attribute: "additional_comments")
  applicantFilter: ApplicantFilterBelongsTo!
  # requestedDate will be set to current date in Eloquent model.
  # status will be set to PENDING in Eloquent model.
  wasEmpty: Boolean @rename(attribute: "was_empty")
}

input UpdatePoolCandidateSearchRequestInput {
  adminNotes: String @rename(attribute: "admin_notes")
  status: PoolCandidateSearchStatus
}

input SkillBelongsToMany {
  sync: [ID!]
}
input CreateSkillFamilyInput {
  key: KeyString!
    @rules(
      apply: ["unique:skill_families,key"]
      messages: [{ rule: "unique", message: "SkillFamilyKeyStringInUse" }]
    )
  name: LocalizedStringInput!
  description: LocalizedStringInput
  skills: SkillBelongsToMany
  category: SkillCategory!
}

input UpdateSkillFamilyInput {
  name: LocalizedStringInput
  description: LocalizedStringInput
  skills: SkillBelongsToMany
  category: SkillCategory
}

input SkillFamilyBelongsToMany {
  sync: [ID!]
}

input SkillKeywordsInput {
  en: [String!]
  fr: [String!]
}

input CreateSkillInput {
  key: KeyString!
  name: LocalizedStringInput!
  description: LocalizedStringInput
  families: SkillFamilyBelongsToMany
  keywords: SkillKeywordsInput
}

input UpdateSkillInput {
  name: LocalizedStringInput!
  description: LocalizedStringInput
  families: SkillFamilyBelongsToMany
  keywords: SkillKeywordsInput
}

input WorkExperienceInput {
  role: String
  organization: String
  division: String
  startDate: Date @rename(attribute: "start_date")
  endDate: Date @rename(attribute: "end_date")
  details: String
  skills: UpdateExperienceSkills @spread
}
input PersonalExperienceInput {
  title: String
  description: String
  startDate: Date @rename(attribute: "start_date")
  endDate: Date @rename(attribute: "end_date")
  details: String
  skills: UpdateExperienceSkills @spread
}
input CommunityExperienceInput {
  title: String
  organization: String
  project: String
  startDate: Date @rename(attribute: "start_date")
  endDate: Date @rename(attribute: "end_date")
  details: String
  skills: UpdateExperienceSkills @spread
}
input EducationExperienceInput {
  institution: String
  areaOfStudy: String @rename(attribute: "area_of_study")
  thesisTitle: String @rename(attribute: "thesis_title")
  startDate: Date @rename(attribute: "start_date")
  endDate: Date @rename(attribute: "end_date")
  type: EducationType
  status: EducationStatus
  details: String
  skills: UpdateExperienceSkills @spread
}
input AwardExperienceInput {
  title: String
  issuedBy: String @rename(attribute: "issued_by")
  awardedDate: Date @rename(attribute: "awarded_date")
  awardedTo: AwardedTo @rename(attribute: "awarded_to")
  awardedScope: AwardedScope @rename(attribute: "awarded_scope")
  details: String
  skills: UpdateExperienceSkills @spread
}

input UpdateExperienceSkills {
  connect: [ConnectExperienceSkills!] @resolveWith(method: "connectSkills")
  disconnect: [ID!] @resolveWith(method: "disconnectSkills")
  sync: [ConnectExperienceSkills!] @resolveWith(method: "syncSkills")
}

input ConnectExperienceSkills {
  id: ID!
  details: String
}

input WorkExperienceHasMany {
  create: [WorkExperienceInput!]
}
input PersonalExperienceHasMany {
  create: [PersonalExperienceInput!]
}
input CommunityExperienceHasMany {
  create: [CommunityExperienceInput!]
}
input EducationExperienceHasMany {
  create: [EducationExperienceInput!]
}
input AwardExperienceHasMany {
  create: [AwardExperienceInput!]
}
input GenericJobTitleBelongsToMany {
  sync: [ID!]
}

input CreatePoolInput {
  classifications: ClassificationBelongsToMany
}

input CreateScreeningQuestionInput {
  question: LocalizedStringInput!
  sortOrder: Int @rename(attribute: "sort_order")
}

input UpdateScreeningQuestionInput {
  id: ID!
  question: LocalizedStringInput
  sortOrder: Int @rename(attribute: "sort_order")
}

input UpdateScreeningQuestionsHasMany {
  create: [CreateScreeningQuestionInput!]
  update: [UpdateScreeningQuestionInput!]
  delete: [ID!]
}

input UpdatePoolInput {
  # Pool name and classification
  name: LocalizedStringInput
  classifications: ClassificationBelongsToMany
  stream: PoolStream
  processNumber: String @rename(attribute: "process_number")
  # Closing date
  closingDate: DateTime
    @rename(attribute: "closing_date")
    @rules(
      apply: ["after:today"]
      messages: [{ rule: "after", message: "UpdatePoolClosingDate" }]
    )
  # Your impact
  yourImpact: LocalizedStringInput @rename(attribute: "your_impact")
  # Work Tasks
  keyTasks: LocalizedStringInput @rename(attribute: "key_tasks")
  # Essential skills and Asset skills
  essentialSkills: SkillBelongsToMany
  nonessentialSkills: SkillBelongsToMany
  # Other requirements
  language: PoolLanguage @rename(attribute: "advertisement_language")
  securityClearance: SecurityStatus @rename(attribute: "security_clearance")
  location: LocalizedStringInput @rename(attribute: "advertisement_location")
  isRemote: Boolean @rename(attribute: "is_remote")
  publishingGroup: PublishingGroup @rename(attribute: "publishing_group")
  screeningQuestions: UpdateScreeningQuestionsHasMany
}

input RolesInput
  @validator(class: "App\\GraphQL\\Validators\\RolesInputValidator") {
  roles: [ID!]!
  team: ID
}

input RoleAssignmentHasMany {
  attach: RolesInput
  detach: RolesInput
  sync: RolesInput
}
input ScreeningResponseBelongsTo {
  connect: ID!
}

input CreateScreeningQuestionResponseInput {
  screeningQuestion: ScreeningResponseBelongsTo!
  answer: String!
}

input UpdateScreeningQuestionResponseInput {
  id: ID!
  answer: String
}

input UpdateScreeningQuestionResponsesHasMany {
  create: [CreateScreeningQuestionResponseInput!]
  update: [UpdateScreeningQuestionResponseInput!]
  delete: [ID!]
}

input UpdateEducationExperiencesRequirementBelongsToMany {
  sync: [ID!]
}

input UpdateApplicationInput {
  # can only connect a step, not disconnect or sync
  insertSubmittedStep: ApplicationStep
  screeningQuestionResponses: UpdateScreeningQuestionResponsesHasMany
  educationRequirementOption: EducationRequirementOption
    @rename(attribute: "education_requirement_option")
  # experiences for meeting minimum criteria
  educationRequirementAwardExperiences: UpdateEducationExperiencesRequirementBelongsToMany
  educationRequirementCommunityExperiences: UpdateEducationExperiencesRequirementBelongsToMany
  educationRequirementEducationExperiences: UpdateEducationExperiencesRequirementBelongsToMany
  educationRequirementPersonalExperiences: UpdateEducationExperiencesRequirementBelongsToMany
  educationRequirementWorkExperiences: UpdateEducationExperiencesRequirementBelongsToMany
}

type Mutation {
  createUser(user: CreateUserInput! @spread): User
    @create
    @guard
    @can(ability: "create")
    @throttle(maxAttempts: 100)
  updateUserAsUser(id: ID!, user: UpdateUserAsUserInput! @spread): User
    @update
    @guard
    @can(ability: "update", find: "id", injectArgs: true)
  updateUserAsAdmin(id: ID!, user: UpdateUserAsAdminInput! @spread): User
    @update
    @guard
    @can(ability: "update", find: "id", injectArgs: true)
  deleteUser(id: ID!): User
    @delete(globalId: false)
    @guard
    @can(ability: "delete", find: "id")
  createPoolCandidateAsAdmin(
    poolCandidate: CreatePoolCandidateAsAdminInput! @spread
  ): PoolCandidate
    @create
    @guard
    @can(ability: "create")
    @injectNow(name: "submitted_at")
  updatePoolCandidateAsAdmin(
    id: ID!
    poolCandidate: UpdatePoolCandidateAsAdminInput! @spread
  ): PoolCandidate @update @guard @can(ability: "updateAsAdmin", find: "id")
  deletePoolCandidate(id: ID!): PoolCandidate
    @delete(globalId: false)
    @guard
    @can(ability: "delete", find: "id")
  createClassification(
    classification: CreateClassificationInput! @spread
  ): Classification @create @guard @can(ability: "create")
  updateClassification(
    id: ID!
    classification: UpdateClassificationInput! @spread
  ): Classification @update @guard @can(ability: "update", find: "id")
  deleteClassification(id: ID!): Classification
    @delete(globalId: false)
    @guard
    @can(ability: "delete", find: "id")
  createDepartment(department: CreateDepartmentInput! @spread): Department
    @create
    @guard
    @can(ability: "create")
  updateDepartment(
    id: ID!
    department: UpdateDepartmentInput! @spread
  ): Department @update @can(ability: "update", find: "id")
  deleteDepartment(id: ID!): Department
    @delete(globalId: false)
    @guard
    @can(ability: "delete", find: "id")

  # SearchRequest mutations
  createPoolCandidateSearchRequest(
    poolCandidateSearchRequest: CreatePoolCandidateSearchRequestInput! @spread
  ): PoolCandidateSearchRequest @create @can(ability: "create")
  updatePoolCandidateSearchRequest(
    id: ID!
    poolCandidateSearchRequest: UpdatePoolCandidateSearchRequestInput! @spread
  ): PoolCandidateSearchRequest
    @update
    @guard
    @can(ability: "update", find: "id")
  deletePoolCandidateSearchRequest(id: ID!): PoolCandidateSearchRequest
    @delete(globalId: false)
    @guard
    @can(ability: "delete", find: "id")

  createSkillFamily(skillFamily: CreateSkillFamilyInput! @spread): SkillFamily
    @create
    @guard
    @can(ability: "create")
  updateSkillFamily(
    id: ID!
    skillFamily: UpdateSkillFamilyInput! @spread
  ): SkillFamily @update @guard @can(ability: "update", find: "id")
  createSkill(skill: CreateSkillInput! @spread): Skill
    @create
    @guard
    @can(ability: "create")
  updateSkill(id: ID!, skill: UpdateSkillInput! @spread): Skill
    @update
    @guard
    @can(ability: "update", find: "id")
  createWorkExperience(
    userId: ID! @rename(attribute: "user_id")
    workExperience: WorkExperienceInput! @spread
  ): WorkExperience @create @can(ability: "create", injectArgs: true)
  createPersonalExperience(
    userId: ID! @rename(attribute: "user_id")
    personalExperience: PersonalExperienceInput! @spread
  ): PersonalExperience @create @can(ability: "create", injectArgs: true)
  createCommunityExperience(
    userId: ID! @rename(attribute: "user_id")
    communityExperience: CommunityExperienceInput! @spread
  ): CommunityExperience @create @can(ability: "create", injectArgs: true)
  createEducationExperience(
    userId: ID! @rename(attribute: "user_id")
    educationExperience: EducationExperienceInput! @spread
  ): EducationExperience @create @can(ability: "create", injectArgs: true)
  createAwardExperience(
    userId: ID! @rename(attribute: "user_id")
    awardExperience: AwardExperienceInput! @spread
  ): AwardExperience @create @can(ability: "create", injectArgs: true)
  updateWorkExperience(
    id: ID!
    workExperience: WorkExperienceInput! @spread
  ): WorkExperience @update @guard @can(ability: "update", find: "id")
  updatePersonalExperience(
    id: ID!
    personalExperience: PersonalExperienceInput! @spread
  ): PersonalExperience @update @guard @can(ability: "update", find: "id")
  updateCommunityExperience(
    id: ID!
    communityExperience: CommunityExperienceInput! @spread
  ): CommunityExperience @update @guard @can(ability: "update", find: "id")
  updateEducationExperience(
    id: ID!
    educationExperience: EducationExperienceInput! @spread
  ): EducationExperience @update @guard @can(ability: "update", find: "id")
  updateAwardExperience(
    id: ID!
    awardExperience: AwardExperienceInput! @spread
  ): AwardExperience @update @guard @can(ability: "update", find: "id")
  deleteWorkExperience(id: ID!): WorkExperience
    @delete(globalId: false)
    @guard
    @can(ability: "delete", find: "id")
  deletePersonalExperience(id: ID!): PersonalExperience
    @delete(globalId: false)
    @guard
    @can(ability: "delete", find: "id")
  deleteCommunityExperience(id: ID!): CommunityExperience
    @delete(globalId: false)
    @guard
    @can(ability: "delete", find: "id")
  deleteEducationExperience(id: ID!): EducationExperience
    @delete(globalId: false)
    @guard
    @can(ability: "delete", find: "id")
  deleteAwardExperience(id: ID!): AwardExperience
    @delete(globalId: false)
    @guard
    @can(ability: "delete", find: "id")

  # Pool mutations
  createPool(
    userId: ID! @rename(attribute: "user_id")
    teamId: ID! @rename(attribute: "team_id")
    pool: CreatePoolInput! @spread
  ): Pool @create @guard @can(ability: "create", injectArgs: true)
  duplicatePool(id: ID!, teamId: ID! @rename(attribute: "team_id")): Pool
    @guard
    @can(ability: "duplicate", injectArgs: true)
  updatePool(id: ID!, pool: UpdatePoolInput! @spread): Pool
    @update
    @guard
    @can(ability: "updateDraft", find: "id")
  publishPool(id: ID!): Pool @guard @can(ability: "publish", find: "id")
  changePoolClosingDate(
    id: ID!
    newClosingDate: DateTime!
      @rename(attribute: "new_closing_date")
      @rules(
        apply: ["after:today"]
        messages: [{ rule: "after", message: "UpdatePoolClosingDate" }]
      )
  ): Pool @guard @can(ability: "changePoolClosingDate", find: "id")
  closePool(id: ID!): Pool @guard @can(ability: "closePool", find: "id")
  deletePool(id: ID!): Pool
    @delete(globalId: false)
    @guard
    @can(ability: "deleteDraft", find: "id")
  deletePool(id: ID!): Pool
    @delete(model: "Pool", globalId: false)
    @guard
    @can(ability: "deleteDraft", find: "id")

  # Application mutations
  archiveApplication(id: ID!): PoolCandidate
    @guard
    @can(ability: "archive", find: "id")
  changeApplicationSuspendedAt(id: ID!, isSuspended: Boolean!): PoolCandidate
    @guard
    @can(ability: "suspend", find: "id")
  createApplication(userId: ID!, poolId: ID!): PoolCandidate
    @can(ability: "createDraft")
  deleteApplication(id: ID!): Boolean
    @guard
    @can(ability: "delete", find: "id", model: "PoolCandidate")
  submitApplication(id: ID!, signature: String!): PoolCandidate
    @guard
    @can(ability: "submit", find: "id")
  updateApplication(
    id: ID!
    application: UpdateApplicationInput! @spread
  ): PoolCandidate
    @update(model: "PoolCandidate")
    @guard
    @can(ability: "update", find: "id", model: "PoolCandidate")

  # Teams mutations
  createTeam(team: CreateTeamInput! @spread): Team
    @create
    @can(ability: "create")
  updateTeam(id: UUID!, team: UpdateTeamInput! @spread): Team
    @update
    @can(ability: "update")
  deleteTeam(id: UUID!): Team
    @delete(globalId: false)
    @guard
    @can(ability: "delete", find: "id")

  # Notifications
  markNotificationAsRead(id: UUID!): Notification
}
